{% extends "base.html" %}

{% block title %}Dashboard - Spendsight{% endblock %}

{% block navbar_controls %}
{% if statistics and statistics.count > 0 %}
<div class="navbar-controls">
    <div class="budget-input-inline" id="budgetInputSection" style="display: none;">
        <span class="budget-currency">$</span>
        <input type="text" class="budget-input-nav" id="budgetInput" placeholder="0" inputmode="decimal">
        <div class="budget-timeframe-toggle">
            <button data-budget-tf="monthly" class="active">M</button>
            <button data-budget-tf="weekly">W</button>
        </div>
        <button class="budget-set-btn" onclick="saveBudget()" title="Set Budget">✓</button>
    </div>
    <div class="time-toggle">
        <button data-period="days" class="active">Days</button>
        <button data-period="weeks">Weeks</button>
        <button data-period="months">Months</button>
        <button data-period="years">Years</button>
    </div>
    <div class="period-nav">
        <button class="period-nav-btn" id="periodPrev" onclick="navigatePeriod(-1)" title="Previous">◀</button>
        <button class="period-nav-btn" id="periodNext" onclick="navigatePeriod(1)" title="Next">▶</button>
    </div>
    
    <select class="filter-select" id="sortOrder" onchange="applySorting()">
        <option value="amount-desc" selected>Amount (High→Low)</option>
        <option value="amount-asc">Amount (Low→High)</option>
        <option value="date-desc">Date (Newest)</option>
        <option value="date-asc">Date (Oldest)</option>
    </select>
    
    <div class="timeframe-badge" id="timeframeBadge" title="Currently viewing this date range">
        <span class="tf-range" id="timeframeRange">Loading...</span>
    </div>
    <button class="add-filter-btn" onclick="openFilterPanel()" title="Add filters">+</button>
    <div id="filterChips"></div>
    <button class="clear-all-filters" id="clearAllBtn" onclick="clearAllFilters()" style="display: none;">Clear All</button>
</div>
{% endif %}
{% endblock %}

{% block extra_css %}
<style>
    /* Budget Input in Navbar */
    .budget-input-inline {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.2rem 0.5rem;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 6px;
    }
    
    .budget-currency {
        font-size: 0.8rem;
        font-weight: 600;
        color: white;
    }
    
    .budget-input-nav {
        width: 70px;
        padding: 0.2rem 0.3rem;
        background: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        font-size: 0.8rem;
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
        color: white;
        text-align: right;
        -moz-appearance: textfield;
    }
    
    .budget-input-nav::-webkit-outer-spin-button,
    .budget-input-nav::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
    
    .budget-input-nav::placeholder {
        color: rgba(255, 255, 255, 0.5);
    }
    
    .budget-input-nav:focus {
        outline: none;
        border-color: rgba(255, 255, 255, 0.6);
        background: rgba(255, 255, 255, 0.2);
    }
    
    .budget-timeframe-toggle {
        display: flex;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
        padding: 2px;
        gap: 1px;
    }
    
    .budget-timeframe-toggle button {
        padding: 0.15rem 0.35rem;
        border: none;
        background: transparent;
        border-radius: 3px;
        font-size: 0.65rem;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: var(--transition);
    }
    
    .budget-timeframe-toggle button:hover {
        color: white;
    }
    
    .budget-timeframe-toggle button.active {
        background: rgba(16, 185, 129, 0.8);
        color: white;
    }
    
    .budget-set-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        height: 22px;
        background: rgba(16, 185, 129, 0.8);
        border: none;
        border-radius: 4px;
        color: white;
        font-size: 0.75rem;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .budget-set-btn:hover {
        background: rgba(16, 185, 129, 1);
        transform: scale(1.05);
    }
    
    /* Control Bar - Unified Filters */
    .control-bar {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.5rem 0.75rem;
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        margin-bottom: 0.5rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        flex-wrap: wrap;
    }
    
    .control-group {
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }
    
    .control-label {
        font-size: 0.65rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 500;
    }
    
    .time-toggle {
        display: flex;
        background: var(--bg-tertiary);
        border-radius: 4px;
        padding: 2px;
        gap: 1px;
    }
    
    .time-toggle button {
        padding: 0.2rem 0.45rem;
        border: none;
        background: transparent;
        border-radius: 3px;
        font-size: 0.65rem;
        font-weight: 500;
        color: var(--text-secondary);
        cursor: pointer;
        transition: var(--transition);
    }
    
    .time-toggle button:hover { color: var(--text-primary); }
    .time-toggle button.active { background: var(--primary-color); color: white; }
    
    .filter-select {
        padding: 0.2rem 0.4rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.65rem;
        font-weight: 500;
        color: var(--text-primary);
        background: var(--bg-primary);
        cursor: pointer;
    }
    
    .filter-select:focus { border-color: var(--primary-color); outline: none; }
    
    .divider {
        width: 1px;
        height: 20px;
        background: var(--border-color);
    }
    
    /* Multi-Filter System */
    .filters-container {
        display: flex;
        align-items: center;
        gap: 0.35rem;
        flex-wrap: wrap;
    }
    
    .add-filter-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 22px;
        height: 22px;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
        border: 1px dashed var(--primary-light);
        border-radius: 4px;
        color: var(--primary-color);
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .add-filter-btn:hover {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.25), rgba(139, 92, 246, 0.25));
        border-style: solid;
        transform: scale(1.05);
    }
    
    /* Timeframe Badge - Shows current visible date range */
    .timeframe-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.25rem 0.6rem;
        background: linear-gradient(135deg, #6366f1, #8b5cf6);
        border-radius: 6px;
        font-size: 0.7rem;
        font-weight: 600;
        color: white;
        box-shadow: 0 2px 8px rgba(99, 102, 241, 0.35);
        letter-spacing: 0.02em;
    }
    
    .timeframe-badge .tf-icon {
        font-size: 0.75rem;
    }
    
    .timeframe-badge .tf-range {
        white-space: nowrap;
    }
    
    .filter-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.15rem 0.4rem;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.12), rgba(139, 92, 246, 0.12));
        border: 1px solid rgba(99, 102, 241, 0.25);
        border-radius: 12px;
        font-size: 0.65rem;
        color: var(--text-primary);
        animation: chipIn 0.2s ease-out;
    }
    
    @keyframes chipIn {
        from { opacity: 0; transform: scale(0.8); }
        to { opacity: 1; transform: scale(1); }
    }
    
    .filter-chip .chip-type {
        color: var(--text-secondary);
        font-weight: 500;
        text-transform: uppercase;
        font-size: 0.55rem;
    }
    
    .filter-chip .chip-value {
        font-weight: 600;
        color: var(--primary-color);
    }
    
    .filter-chip .chip-remove {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 14px;
        height: 14px;
        background: transparent;
        border: none;
        border-radius: 50%;
        color: var(--text-light);
        font-size: 0.6rem;
        cursor: pointer;
        transition: var(--transition);
        padding: 0;
        margin-left: 0.1rem;
    }
    
    .filter-chip .chip-remove:hover {
        background: var(--danger-color);
        color: white;
    }
    
    .clear-all-filters {
        padding: 0.15rem 0.35rem;
        background: var(--danger-color);
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 0.6rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .clear-all-filters:hover {
        background: #dc2626;
    }
    
    /* Filter Panel */
    .filter-panel-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(2px);
        z-index: 999;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s ease, visibility 0.2s ease;
    }
    
    .filter-panel-overlay.show {
        opacity: 1;
        visibility: visible;
    }
    
    .filter-panel {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.95);
        background: var(--bg-primary);
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        width: 580px;
        max-width: 95vw;
        max-height: 85vh;
        overflow: hidden;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s ease;
    }
    
    .filter-panel.show {
        opacity: 1;
        visibility: visible;
        transform: translate(-50%, -50%) scale(1);
    }
    
    .filter-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
    }
    
    .filter-panel-header h3 {
        font-size: 0.9rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }
    
    .filter-panel-close {
        background: rgba(255, 255, 255, 0.2);
        border: none;
        color: white;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        cursor: pointer;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
    }
    
    .filter-panel-close:hover {
        background: rgba(255, 255, 255, 0.3);
    }
    
    .filter-panel-body {
        padding: 1rem;
        overflow-y: auto;
        max-height: calc(85vh - 120px);
    }
    
    .filter-section {
        margin-bottom: 1rem;
    }
    
    .filter-section:last-child {
        margin-bottom: 0;
    }
    
    .filter-section-title {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.5rem;
        display: flex;
        align-items: center;
        gap: 0.3rem;
    }
    
    .date-range-inputs {
        display: flex;
        gap: 0.75rem;
        align-items: center;
    }
    
    .date-input-group {
        flex: 1;
    }
    
    .date-input-group label {
        display: block;
        font-size: 0.65rem;
        color: var(--text-secondary);
        margin-bottom: 0.2rem;
    }
    
    .date-input-group input {
        width: 100%;
        padding: 0.4rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.75rem;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .date-input-group input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
    }
    
    .tag-columns {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.75rem;
    }
    
    .tag-column {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 0.5rem;
    }
    
    .tag-column-title {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.4rem;
        padding-bottom: 0.3rem;
        border-bottom: 1px solid var(--border-color);
    }
    
    .tag-options {
        max-height: 200px;
        overflow-y: auto;
    }
    
    .tag-option {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.3rem 0.4rem;
        border-radius: 4px;
        cursor: pointer;
        transition: var(--transition);
        font-size: 0.7rem;
    }
    
    .tag-option:hover {
        background: var(--bg-tertiary);
    }
    
    .tag-option.selected {
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.15), rgba(139, 92, 246, 0.15));
    }
    
    .tag-option input[type="checkbox"] {
        width: 14px;
        height: 14px;
        accent-color: var(--primary-color);
    }
    
    .tag-option span {
        color: var(--text-primary);
    }
    
    /* Untagged Filter Options */
    .untagged-options {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .untagged-option {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 0.6rem;
        border-radius: 6px;
        cursor: pointer;
        transition: var(--transition);
        font-size: 0.75rem;
        background: var(--bg-secondary);
        border: 1px solid var(--border-color);
    }
    
    .untagged-option:hover {
        background: var(--bg-tertiary);
        border-color: var(--primary-color);
    }
    
    .untagged-option.selected {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(251, 191, 36, 0.15));
        border-color: #f59e0b;
    }
    
    .untagged-option input[type="checkbox"] {
        width: 14px;
        height: 14px;
        accent-color: #f59e0b;
    }
    
    .untagged-option span {
        color: var(--text-primary);
    }
    
    .untagged-hint {
        font-size: 0.65rem;
        color: var(--text-secondary);
        font-style: italic;
        margin-left: auto;
    }
    
    .filter-panel-footer {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        background: var(--bg-secondary);
        border-top: 1px solid var(--border-color);
    }
    
    .filter-panel-footer .btn-reset {
        padding: 0.4rem 0.75rem;
        background: transparent;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        color: var(--text-secondary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .filter-panel-footer .btn-reset:hover {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    .filter-panel-footer .btn-apply {
        padding: 0.4rem 1rem;
        background: var(--primary-color);
        border: none;
        border-radius: 6px;
        color: white;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .filter-panel-footer .btn-apply:hover {
        background: var(--primary-dark);
    }
    
    /* Legacy support */
    .active-filter {
        display: none;
    }
    
    /* Charts Container */
    .charts-container {
        display: grid;
        grid-template-columns: 1.4fr 1fr;
        gap: 0.35rem;
        margin-bottom: 0.5rem;
        overflow: visible;
        position: relative;
        z-index: 1;
    }
    
    .chart-card {
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        padding: 0.5rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        overflow: visible;
    }
    
    .line-chart-card {
        flex: 1;
    }
    
    .pie-analytics-wrapper {
        display: flex;
        gap: 0.35rem;
    }
    
    .pie-chart-card {
        flex: 1;
        min-width: 0;
    }
    
    .analytics-panel {
        flex: 0 0 auto;
        width: 120px;
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        padding: 0.4rem 0.5rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
    }
    
    .analytics-title {
        font-size: 0.65rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.35rem;
        display: flex;
        align-items: center;
        gap: 0.2rem;
    }
    
    .analytics-stats {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
        flex: 1;
        justify-content: center;
    }
    
    .analytics-stat {
        display: flex;
        flex-direction: column;
        padding: 0.3rem 0.4rem;
        background: var(--bg-secondary);
        border-radius: 4px;
        border-left: 2px solid var(--primary-color);
    }
    
    .analytics-stat.total-stat {
        border-left-color: var(--danger-color);
    }
    
    .analytics-stat.count-stat {
        border-left-color: var(--info-color);
    }
    
    .analytics-label {
        font-size: 0.55rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 500;
        letter-spacing: 0.2px;
        margin-bottom: 0.1rem;
    }
    
    .analytics-value {
        font-size: 0.9rem;
        font-weight: 700;
        color: var(--primary-color);
        font-family: 'JetBrains Mono', monospace;
    }
    
    .analytics-value.total-value {
        color: var(--danger-color);
    }
    
    .analytics-value.count-value {
        color: var(--info-color);
    }
    
    .chart-title {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.35rem;
        display: flex;
        align-items: center;
        gap: 0.25rem;
        position: relative;
    }
    
    .line-chart-container { position: relative; height: 180px; overflow: visible; }
    .pie-chart-container { position: relative; height: 180px; overflow: visible; }
    
    .chart-card canvas { cursor: pointer; }
    
    /* Breakdown Selector in Title */
    .breakdown-selector {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        color: var(--primary-color);
        cursor: pointer;
        padding: 0.1rem 0.3rem;
        border-radius: 4px;
        transition: var(--transition);
    }
    
    .breakdown-selector:hover {
        background: rgba(99, 102, 241, 0.1);
    }
    
    .dropdown-arrow {
        font-size: 0.6rem;
        opacity: 0.7;
    }
    
    .breakdown-menu {
        position: absolute;
        top: 100%;
        left: 0;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 130px;
        z-index: 100;
        display: none;
        overflow: hidden;
    }
    
    .breakdown-menu.show {
        display: block;
    }
    
    .breakdown-option {
        padding: 0.4rem 0.6rem;
        font-size: 0.7rem;
        font-weight: 400;
        color: var(--text-primary);
        cursor: pointer;
        transition: var(--transition);
    }
    
    .breakdown-option:hover {
        background: var(--bg-tertiary);
    }
    
    .breakdown-option.selected {
        background: var(--primary-color);
        color: white;
    }
    
    /* Line chart breakdown dropdown */
    .line-breakdown-selector {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        color: var(--primary-color);
        cursor: pointer;
        padding: 0.1rem 0.4rem;
        border-radius: 4px;
        transition: var(--transition);
        margin-left: auto;
        font-size: 0.7rem;
        font-weight: 500;
        background: rgba(99, 102, 241, 0.08);
        border: 1px solid transparent;
    }
    
    .line-breakdown-selector:hover {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.3);
    }
    
    .line-breakdown-menu {
        position: absolute;
        top: 100%;
        right: 0;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        min-width: 140px;
        z-index: 100;
        display: none;
        overflow: hidden;
    }
    
    .line-breakdown-menu.show {
        display: block;
    }
    
    .line-breakdown-option {
        padding: 0.45rem 0.7rem;
        font-size: 0.7rem;
        font-weight: 400;
        cursor: pointer;
        transition: var(--transition);
        color: var(--text-primary);
    }
    
    .line-breakdown-option:hover {
        background: var(--bg-secondary);
    }
    
    .line-breakdown-option.selected {
        background: var(--primary-color);
        color: white;
    }
    
    .line-breakdown-divider {
        height: 1px;
        background: var(--border-color);
        margin: 0.25rem 0;
    }
    
    .line-toggle-option {
        display: flex;
        align-items: center;
        gap: 0.4rem;
    }
    
    .toggle-check {
        font-size: 0.65rem;
        opacity: 0;
        color: var(--success-color);
        font-weight: 600;
        width: 0.8rem;
    }
    
    .toggle-check.active {
        opacity: 1;
    }
    
    /* Period label in chart title */
    .chart-period-label {
        font-size: 0.65rem;
        font-weight: 500;
        color: var(--text-secondary);
        background: var(--bg-tertiary);
        padding: 0.1rem 0.4rem;
        border-radius: 4px;
        margin-left: 0.35rem;
    }
    
    /* Period navigation arrows */
    .period-nav {
        display: inline-flex;
        align-items: center;
        gap: 0.15rem;
        margin-left: 0.25rem;
    }
    
    .period-nav-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        padding: 0;
        background: rgba(139, 92, 246, 0.15);
        border: none;
        border-radius: 3px;
        color: var(--secondary-color);
        cursor: pointer;
        font-size: 0.65rem;
        transition: var(--transition);
        opacity: 0.7;
    }
    
    .period-nav-btn:hover {
        background: rgba(139, 92, 246, 0.3);
        opacity: 1;
    }
    
    .period-nav-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
    }
    
    /* ============ BUDGET MODE STYLES ============ */
    
    /* Budget Mode Layout - replaces line chart area */
    .budget-mode-row {
        display: none;
        gap: 0.35rem;
        flex: 1;
    }
    
    .budget-mode-row.active {
        display: flex;
    }
    
    /* Hide line chart when budget mode is active */
    .line-chart-card.budget-hidden {
        display: none !important;
    }
    
    /* Budget Stats Panel (left side) */
    .budget-stats-panel {
        flex: 0 0 140px;
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        padding: 0.5rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
    }
    
    /* Budget Status Column */
    .budget-status-column {
        flex: 0 0 180px;
        display: flex;
        flex-direction: column;
    }
    
    .budget-stats-title {
        font-size: 0.65rem;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: 0.25rem;
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .budget-stat {
        display: flex;
        flex-direction: column;
        padding: 0.35rem 0.5rem;
        background: var(--bg-secondary);
        border-radius: 6px;
        border-left: 3px solid var(--primary-color);
    }
    
    .budget-stat.income-stat {
        border-left-color: var(--success-color);
    }
    
    .budget-stat.spending-power-stat {
        border-left-color: #8b5cf6;
    }
    
    .budget-stat.discretionary-stat {
        border-left-color: #f59e0b;
    }
    
    .budget-stat-label {
        font-size: 0.55rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 500;
        letter-spacing: 0.2px;
        margin-bottom: 0.15rem;
    }
    
    .budget-stat-value {
        font-size: 0.95rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .budget-stat-value.positive { color: var(--success-color); }
    .budget-stat-value.negative { color: var(--danger-color); }
    
    /* Budget Status Card (compact) */
    .budget-status-card {
        flex: 1;
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        padding: 0.6rem;
        box-shadow: var(--shadow-sm);
        border: 2px solid var(--border-color);
    }
    
    .budget-status-card.passed {
        border-color: var(--success-color);
        background: linear-gradient(135deg, rgba(16, 185, 129, 0.05), rgba(5, 150, 105, 0.02));
    }
    
    .budget-status-card.failed {
        border-color: var(--danger-color);
        background: linear-gradient(135deg, rgba(239, 68, 68, 0.05), rgba(220, 38, 38, 0.02));
    }
    
    .budget-status-card.warning {
        border-color: var(--warning-color);
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.05), rgba(217, 119, 6, 0.02));
    }
    
    .budget-status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 1rem;
    }
    
    .budget-status-title {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .budget-status-icon {
        font-size: 2.5rem;
    }
    
    .budget-status-text h3 {
        font-size: 1.2rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 0.1rem;
    }
    
    .budget-status-text p {
        font-size: 0.8rem;
        color: var(--text-secondary);
    }
    
    .budget-status-numbers {
        text-align: right;
    }
    
    .budget-spent {
        font-size: 1.8rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .budget-spent.positive { color: var(--success-color); }
    .budget-spent.negative { color: var(--danger-color); }
    
    .budget-of {
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    
    .budget-limit {
        font-weight: 600;
        color: var(--text-primary);
        font-family: 'JetBrains Mono', monospace;
    }
    
    .budget-progress-container {
        margin-top: 0.75rem;
    }
    
    .budget-progress-bar {
        height: 8px;
        background: var(--bg-tertiary);
        border-radius: 4px;
        overflow: hidden;
    }
    
    .budget-progress-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.5s ease;
    }
    
    .budget-progress-fill.passed { background: linear-gradient(90deg, #10b981, #34d399); }
    .budget-progress-fill.warning { background: linear-gradient(90deg, #f59e0b, #fbbf24); }
    .budget-progress-fill.failed { background: linear-gradient(90deg, #ef4444, #f87171); }
    
    .budget-progress-info {
        display: flex;
        justify-content: space-between;
        margin-top: 0.5rem;
        font-size: 0.75rem;
    }
    
    .budget-percentage {
        font-weight: 600;
    }
    
    .budget-percentage.passed { color: var(--success-color); }
    .budget-percentage.warning { color: var(--warning-color); }
    .budget-percentage.failed { color: var(--danger-color); }
    
    .budget-remaining {
        color: var(--text-secondary);
    }
    
    .budget-remaining strong.negative {
        color: var(--danger-color);
    }
    
    .no-budget-state {
        text-align: center;
        padding: 0.75rem;
    }
    
    .no-budget-state .icon {
        font-size: 1.5rem;
        margin-bottom: 0.35rem;
    }
    
    .no-budget-state h3 {
        font-size: 0.8rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
    }
    
    .no-budget-state p {
        color: var(--text-secondary);
        font-size: 0.65rem;
    }
    
    /* Personal Analysis Column (Budget Mode) */
    .personal-analysis-column {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-width: 150px;
        max-width: 300px;
    }
    
    .personal-analysis-card {
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
        flex: 1;
        overflow: hidden;
    }
    
    .personal-analysis-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 0.6rem;
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-secondary);
    }
    
    .personal-analysis-title {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 0.35rem;
    }
    
    .personal-analysis-save-status {
        font-size: 0.55rem;
        color: var(--text-light);
        opacity: 0;
        transition: opacity 0.3s ease;
    }
    
    .personal-analysis-save-status.visible {
        opacity: 1;
    }
    
    .personal-analysis-save-status.saved {
        color: var(--success-color);
    }
    
    .personal-analysis-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 0.4rem;
    }
    
    .personal-analysis-textarea {
        flex: 1;
        width: 100%;
        min-height: 100px;
        padding: 0.5rem;
        background: var(--bg-tertiary);
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        font-family: inherit;
        font-size: 0.7rem;
        line-height: 1.5;
        color: var(--text-primary);
        resize: none;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    
    .personal-analysis-textarea::placeholder {
        color: var(--text-light);
        font-style: italic;
    }
    
    .personal-analysis-textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
    }
    
    /* Compact Budget Status for budget mode */
    .budget-status-compact {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .budget-status-main {
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
    }
    
    .budget-status-icon-compact {
        font-size: 1.5rem;
        line-height: 1;
    }
    
    .budget-status-info {
        flex: 1;
    }
    
    .budget-status-label {
        font-size: 0.75rem;
        font-weight: 700;
        color: var(--text-primary);
        margin-bottom: 0.15rem;
    }
    
    .budget-status-amount {
        font-size: 1.1rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        line-height: 1.1;
    }
    
    .budget-status-amount.positive { color: var(--success-color); }
    .budget-status-amount.negative { color: var(--danger-color); }
    
    .budget-status-limit {
        font-size: 0.6rem;
        color: var(--text-secondary);
        margin-top: 0.1rem;
    }
    
    .budget-progress-compact {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .budget-progress-stats {
        display: flex;
        justify-content: space-between;
        font-size: 0.6rem;
    }
    
    .budget-remaining-compact {
        font-family: 'JetBrains Mono', monospace;
        font-weight: 600;
        color: var(--success-color);
    }
    
    .budget-remaining-compact.negative {
        color: var(--danger-color);
    }
    
    .budget-status-message {
        font-size: 0.6rem;
        color: var(--text-secondary);
        text-align: center;
        padding: 0.3rem;
        background: var(--bg-tertiary);
        border-radius: var(--border-radius);
    }
    
    
    /* Cash Transaction Modal - Modern Purple Theme */
    .cash-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.6);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.25s ease;
    }
    
    .cash-modal.show {
        opacity: 1;
        visibility: visible;
    }
    
    .cash-modal.show .cash-modal-content {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    
    .cash-modal-content {
        background: var(--bg-primary);
        border-radius: 16px;
        width: 90%;
        max-width: 440px;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25), 
                    0 0 0 1px rgba(99, 102, 241, 0.1);
        transform: translateY(20px) scale(0.95);
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    .cash-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1.25rem 1.5rem;
        border-bottom: 1px solid var(--border-color);
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.04));
        position: relative;
        overflow: hidden;
    }
    
    .cash-modal-header::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, var(--primary-color), var(--secondary-color), var(--accent-color));
    }
    
    .cash-modal-header h3 {
        font-size: 1.05rem;
        font-weight: 600;
        color: var(--primary-color);
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .cash-modal-header h3::before {
        content: '';
        display: inline-block;
        width: 8px;
        height: 8px;
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        border-radius: 2px;
        transform: rotate(45deg);
    }
    
    .cash-modal-close {
        background: transparent;
        border: none;
        font-size: 1.1rem;
        cursor: pointer;
        color: var(--text-secondary);
        padding: 0.35rem;
        line-height: 1;
        transition: all 0.2s ease;
        border-radius: 6px;
        width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .cash-modal-close:hover {
        color: var(--danger-color);
        background: rgba(239, 68, 68, 0.1);
    }
    
    .cash-modal-body {
        padding: 1.25rem 1.5rem;
    }
    
    .cash-modal-body .form-group {
        margin-bottom: 1rem;
    }
    
    .cash-modal-body .form-group label {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.04em;
        margin-bottom: 0.4rem;
        display: block;
    }
    
    .cash-modal-body .form-group input,
    .cash-modal-body .form-group select {
        width: 100%;
        padding: 0.65rem 0.85rem;
        border: 1.5px solid var(--border-color);
        border-radius: 8px;
        font-size: 0.875rem;
        transition: all 0.2s ease;
        background: var(--bg-secondary);
    }
    
    .cash-modal-body .form-group input:focus,
    .cash-modal-body .form-group select:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.12);
        background: var(--bg-primary);
    }
    
    .cash-modal-body .form-group input::placeholder {
        color: var(--text-light);
    }
    
    .cash-modal-body .form-hint {
        font-size: 0.7rem;
        color: var(--text-light);
        margin-top: 0.3rem;
    }
    
    .cash-modal-body .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }
    
    .cash-modal-actions {
        display: flex;
        gap: 0.75rem;
        margin-top: 1.25rem;
        padding-top: 1.25rem;
        border-top: 1px solid var(--border-color);
    }
    
    .cash-modal-actions .btn {
        flex: 1;
        padding: 0.7rem 1rem;
        font-weight: 500;
        border-radius: 8px;
        transition: all 0.2s ease;
    }
    
    .cash-modal-actions .btn-secondary {
        background: var(--bg-tertiary);
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
    }
    
    .cash-modal-actions .btn-secondary:hover {
        background: var(--bg-secondary);
        color: var(--text-primary);
    }
    
    .cash-modal-actions .btn-primary {
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
        border: none;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
    }
    
    .cash-modal-actions .btn-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(99, 102, 241, 0.35);
    }
    
    .cash-modal-actions .btn-primary:active {
        transform: translateY(0);
    }
    
    /* Recurring Expenses Modal */
    .recurring-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
    }
    
    .recurring-modal.show {
        opacity: 1;
        visibility: visible;
    }
    
    .recurring-modal-content {
        background: var(--bg-primary);
        border-radius: var(--border-radius-xl);
        width: 90%;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: var(--shadow-lg);
    }
    
    .recurring-modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        border-bottom: 1px solid var(--border-color);
        position: sticky;
        top: 0;
        background: var(--bg-primary);
        z-index: 1;
    }
    
    .recurring-modal-header h3 {
        font-size: 1rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    .recurring-modal-close {
        background: transparent;
        border: none;
        font-size: 1.25rem;
        cursor: pointer;
        color: var(--text-secondary);
        padding: 0.25rem;
        line-height: 1;
        transition: var(--transition);
    }
    
    .recurring-modal-close:hover {
        color: var(--danger-color);
    }
    
    .recurring-modal-body {
        padding: 1rem 1.25rem;
    }
    
    /* Recurring Form */
    .recurring-form {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 1rem;
        margin-bottom: 1rem;
    }
    
    .recurring-form h4 {
        font-size: 0.85rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
    }
    
    .form-row {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 0.75rem;
        margin-bottom: 0.75rem;
    }
    
    .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        margin-bottom: 0.75rem;
    }
    
    .form-group label {
        font-size: 0.7rem;
        font-weight: 500;
        color: var(--text-secondary);
    }
    
    .form-group input,
    .form-group select {
        padding: 0.4rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.8rem;
        background: var(--bg-primary);
        color: var(--text-primary);
    }
    
    .form-group input:focus,
    .form-group select:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    
    .form-hint {
        font-size: 0.65rem;
        color: var(--text-light);
        margin-top: 0.25rem;
    }
    
    .keywords-wrapper {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        padding: 0.35rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        min-height: 34px;
        cursor: text;
        background: var(--bg-primary);
    }
    
    .keywords-wrapper:focus-within {
        border-color: var(--primary-color);
    }
    
    .keyword-tag {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        padding: 0.15rem 0.4rem;
        background: rgba(99, 102, 241, 0.15);
        border-radius: 3px;
        font-size: 0.7rem;
        color: var(--primary-color);
    }
    
    .keyword-tag button {
        background: none;
        border: none;
        padding: 0;
        font-size: 0.8rem;
        cursor: pointer;
        color: inherit;
        opacity: 0.7;
        line-height: 1;
    }
    
    .keyword-tag button:hover {
        opacity: 1;
    }
    
    .keyword-input {
        flex: 1;
        min-width: 100px;
        border: none !important;
        padding: 0.2rem !important;
        font-size: 0.75rem !important;
        background: transparent !important;
    }
    
    .keyword-input:focus {
        outline: none;
    }
    
    .preview-box {
        background: rgba(99, 102, 241, 0.08);
        border: 1px solid rgba(99, 102, 241, 0.2);
        border-radius: 6px;
        padding: 0.5rem;
        margin-top: 0.5rem;
        font-size: 0.75rem;
    }
    
    .preview-box .count {
        font-weight: 600;
        color: var(--primary-color);
    }
    
    .preview-list {
        max-height: 80px;
        overflow-y: auto;
        margin-top: 0.35rem;
        font-size: 0.7rem;
        color: var(--text-secondary);
    }
    
    /* Recurring List */
    .recurring-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .recurring-item {
        background: var(--bg-secondary);
        border-radius: var(--border-radius);
        padding: 0.75rem;
        border: 1px solid var(--border-color);
    }
    
    .recurring-item.disabled {
        opacity: 0.5;
    }
    
    .recurring-info {
        display: flex;
        align-items: center;
        gap: 0.75rem;
    }
    
    .recurring-icon {
        font-size: 1.25rem;
    }
    
    .recurring-details {
        flex: 1;
        min-width: 0;
    }
    
    .recurring-name {
        font-weight: 600;
        font-size: 0.85rem;
        margin-bottom: 0.2rem;
    }
    
    .recurring-meta {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.7rem;
        color: var(--text-secondary);
    }
    
    .recurring-frequency {
        display: inline-flex;
        padding: 0.1rem 0.3rem;
        background: rgba(139, 92, 246, 0.15);
        border-radius: 3px;
        font-size: 0.65rem;
        font-weight: 500;
        color: #8b5cf6;
    }
    
    .recurring-keywords {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        margin-top: 0.35rem;
    }
    
    .recurring-keyword {
        font-size: 0.65rem;
        padding: 0.1rem 0.3rem;
        background: var(--bg-tertiary);
        border-radius: 3px;
        color: var(--text-secondary);
    }
    
    .recurring-amount {
        font-weight: 700;
        font-size: 1rem;
        font-family: 'JetBrains Mono', monospace;
        color: var(--danger-color);
    }
    
    .recurring-actions {
        display: flex;
        gap: 0.25rem;
        margin-left: 0.5rem;
    }
    
    .recurring-actions button {
        background: var(--bg-tertiary);
        border: none;
        padding: 0.25rem 0.4rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.7rem;
        transition: var(--transition);
    }
    
    .recurring-actions button:hover {
        background: var(--primary-color);
        color: white;
    }
    
    .recurring-actions .btn-delete:hover {
        background: var(--danger-color);
    }
    
    /* Recurring Totals */
    .recurring-totals {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border-color);
    }
    
    .recurring-total-card {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: 0.5rem;
        text-align: center;
    }
    
    .recurring-total-label {
        font-size: 0.6rem;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 500;
        margin-bottom: 0.2rem;
    }
    
    .recurring-total-value {
        font-size: 0.9rem;
        font-weight: 700;
        font-family: 'JetBrains Mono', monospace;
        color: var(--text-primary);
    }
    
    /* ============ END BUDGET MODE STYLES ============ */
    
    /* Transactions Section - Compact */
    .transactions-section {
        background: var(--bg-primary);
        border-radius: var(--border-radius-lg);
        box-shadow: var(--shadow-sm);
        border: 1px solid var(--border-color);
        overflow: hidden;
    }
    
    .transactions-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.35rem 0.5rem;
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-secondary);
    }
    
    .transactions-header h3 {
        font-size: 0.7rem;
        font-weight: 600;
        color: var(--text-primary);
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .transactions-summary {
        display: flex;
        gap: 0.75rem;
        font-size: 0.65rem;
    }
    
    .summary-stat {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    
    .summary-stat .label {
        color: var(--text-secondary);
    }
    
    .summary-stat .value {
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
    }
    
    .summary-stat .value.expense { color: var(--danger-color); }
    
    /* Transactions List - Compact */
    .transactions-list {
        max-height: 450px;
        overflow-y: auto;
    }
    
    .transaction-item {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 0.5rem;
        padding: 0.3rem 0.5rem;
        border-bottom: 1px solid var(--border-color);
        transition: var(--transition);
        align-items: center;
    }
    
    .transaction-item:hover { background: var(--bg-gradient-subtle); }
    
    .transaction-info {
        display: flex;
        flex-direction: column;
        min-width: 0;
    }
    
    .transaction-description {
        font-weight: 500;
        color: var(--text-primary);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 0.72rem;
    }
    
    .transaction-meta {
        display: flex;
        gap: 0.4rem;
        font-size: 0.62rem;
        color: var(--text-secondary);
    }
    
    .add-tag-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 16px;
        height: 16px;
        border-radius: 3px;
        font-size: 0.7rem;
        font-weight: 500;
        color: var(--text-light);
        background: transparent;
        cursor: pointer;
        transition: var(--transition);
        opacity: 0.4;
    }
    
    .transaction-item:hover .add-tag-btn {
        opacity: 0.7;
    }
    
    .add-tag-btn:hover {
        opacity: 1 !important;
        background: var(--primary-color);
        color: white;
    }
    
    .transaction-category {
        padding: 0.05rem 0.25rem;
        border-radius: 2px;
        font-size: 0.58rem;
        font-weight: 500;
        background: var(--bg-tertiary);
        color: var(--text-primary);
        white-space: nowrap;
        cursor: pointer;
        transition: var(--transition);
        position: relative;
    }
    
    .transaction-category:hover {
        background: var(--primary-light);
        color: white;
    }
    
    .transaction-category.editing {
        background: var(--primary-color);
        color: white;
    }
    
    .transaction-category.uncategorized {
        background: rgba(107, 114, 128, 0.1);
        color: var(--text-light);
        font-style: italic;
    }
    
    .transaction-category.uncategorized:hover {
        background: var(--primary-light);
        color: white;
        font-style: normal;
    }
    
    /* Category edit dropdown */
    .category-edit-wrapper {
        position: relative;
        display: inline-flex;
        align-items: center;
        gap: 0.15rem;
    }
    
    .category-dropdown {
        position: fixed;
        z-index: 1000;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        padding: 0.5rem;
        max-height: 420px;
        overflow-y: auto;
        display: none;
    }
    
    .category-dropdown.show {
        display: block;
    }
    
    .category-dropdown.wide {
        width: 520px;
    }
    
    .category-dropdown.narrow {
        width: 300px;
    }
    
    .dropdown-columns {
        display: flex;
        gap: 0.5rem;
    }
    
    .dropdown-column {
        flex: 1;
        min-width: 0;
    }
    
    .dropdown-column.rule-column {
        flex: 1.1;
        border-right: 1px solid var(--border-color);
        padding-right: 0.5rem;
    }
    
    .dropdown-column.options-column {
        flex: 0.9;
    }
    
    .dropdown-section {
        margin-bottom: 0.5rem;
    }
    
    .dropdown-section:last-child {
        margin-bottom: 0;
    }
    
    .dropdown-section-title {
        font-size: 0.6rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 0.25rem;
        padding-left: 0.1rem;
    }
    
    .category-dropdown .input-with-autocomplete {
        position: relative;
    }
    
    .category-dropdown input {
        width: 100%;
        padding: 0.35rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.75rem;
    }
    
    .category-dropdown input:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    
    .category-options {
        max-height: 120px;
        overflow-y: auto;
        margin-top: 0.25rem;
    }
    
    .category-option {
        padding: 0.3rem 0.4rem;
        font-size: 0.7rem;
        cursor: pointer;
        border-radius: 3px;
        transition: var(--transition);
    }
    
    .category-option:hover {
        background: var(--bg-tertiary);
    }
    
    .category-option.selected {
        background: var(--primary-color);
        color: white;
    }
    
    .dropdown-divider {
        height: 1px;
        background: var(--border-color);
        margin: 0.5rem 0;
    }
    
    /* Inline rule creation in dropdown */
    .inline-rule-form {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: 0.5rem;
    }
    
    .inline-multi-tag-row {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 0.35rem;
        margin-bottom: 0.4rem;
    }
    
    @media (max-width: 500px) {
        .inline-multi-tag-row {
            grid-template-columns: 1fr;
        }
    }
    
    .inline-rule-form .rule-form-group {
        margin-bottom: 0.4rem;
    }
    
    .inline-rule-form .rule-form-group:last-of-type {
        margin-bottom: 0;
    }
    
    .inline-multi-tag-row .rule-form-group {
        margin-bottom: 0;
    }
    
    .inline-rule-form label {
        display: block;
        font-size: 0.62rem;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 0.15rem;
    }
    
    .inline-multi-tag-row input,
    .inline-multi-tag-row select {
        width: 100%;
        padding: 0.3rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.68rem;
    }
    
    .inline-keywords-wrapper {
        display: flex;
        flex-wrap: wrap;
        gap: 0.2rem;
        padding: 0.3rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: white;
        min-height: 32px;
        cursor: text;
    }
    
    .inline-keywords-wrapper:focus-within {
        border-color: var(--primary-color);
    }
    
    .inline-keyword-tag {
        display: inline-flex;
        align-items: center;
        gap: 0.15rem;
        padding: 0.1rem 0.3rem;
        background: var(--primary-color);
        color: white;
        border-radius: 3px;
        font-size: 0.62rem;
        font-weight: 500;
    }
    
    .inline-keyword-tag .remove {
        cursor: pointer;
        opacity: 0.7;
        font-size: 0.75rem;
    }
    
    .inline-keyword-tag .remove:hover {
        opacity: 1;
    }
    
    .inline-keyword-input {
        border: none !important;
        outline: none !important;
        padding: 0.1rem !important;
        font-size: 0.68rem !important;
        flex: 1;
        min-width: 60px;
        background: transparent !important;
    }
    
    .inline-and-connector {
        font-size: 0.55rem;
        color: var(--accent-color);
        font-weight: 600;
    }
    
    .inline-rule-actions {
        display: flex;
        gap: 0.25rem;
        margin-top: 0.4rem;
    }
    
    .inline-rule-actions button {
        flex: 1;
        padding: 0.3rem 0.4rem;
        font-size: 0.68rem;
        font-weight: 500;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-save-inline-rule {
        background: var(--success-color);
        color: white;
    }
    
    .btn-save-inline-rule:hover {
        background: #059669;
    }
    
    .inline-preview {
        font-size: 0.62rem;
        color: var(--text-secondary);
        margin-top: 0.3rem;
        padding: 0.25rem;
        background: var(--bg-tertiary);
        border-radius: 3px;
    }
    
    .inline-preview strong {
        color: var(--primary-color);
    }
    
    .inline-preview-matches {
        max-height: 120px;
        overflow-y: auto;
        margin-top: 0.25rem;
    }
    
    /* Auto-Tag tab two-column layout */
    .auto-tag-columns {
        display: flex;
        gap: 0.75rem;
    }
    
    .auto-tag-preview-column {
        flex: 1;
        min-width: 0;
        border-right: 1px solid var(--border-color);
        padding-right: 0.75rem;
    }
    
    .auto-tag-form-column {
        flex: 1;
        min-width: 0;
    }
    
    .auto-tag-preview-column .inline-preview {
        display: block;
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: 0.5rem;
        min-height: 200px;
        max-height: 280px;
        overflow-y: auto;
    }
    
    .inline-preview-placeholder {
        color: var(--text-secondary);
        font-size: 0.65rem;
        font-style: italic;
        text-align: center;
        padding: 2rem 0.5rem;
    }
    
    .auto-tag-preview-column .inline-preview-matches {
        max-height: none;
    }
    
    /* Tag popup tabs */
    .tag-popup-tabs {
        display: flex;
        gap: 0;
        border-bottom: 1px solid var(--border-color);
        margin-bottom: 0.5rem;
    }
    
    .tag-popup-tab {
        padding: 0.4rem 0.75rem;
        font-size: 0.65rem;
        font-weight: 600;
        color: var(--text-secondary);
        cursor: pointer;
        border-bottom: 2px solid transparent;
        transition: var(--transition);
        white-space: nowrap;
    }
    
    .tag-popup-tab:hover {
        color: var(--text-primary);
        background: var(--bg-tertiary);
    }
    
    .tag-popup-tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
    }
    
    .tag-popup-content {
        display: none;
    }
    
    .tag-popup-content.active {
        display: block;
    }
    
    /* Add Tags tab - grid for categories */
    .tag-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 0.5rem;
    }
    
    .tag-grid.categories-wide {
        grid-template-columns: repeat(3, 1fr);
    }
    
    .tag-column {
        min-width: 0;
    }
    
    .tag-column-title {
        font-size: 0.58rem;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.3px;
        margin-bottom: 0.3rem;
        padding-left: 0.15rem;
    }
    
    .tag-column-items {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .tag-column-items.category-items {
        display: grid;
        grid-template-columns: 1fr;
        gap: 0.2rem;
    }
    
    .tag-grid.categories-wide .tag-column-items.category-items {
        grid-template-columns: repeat(2, 1fr);
    }
    
    .tag-option-btn {
        padding: 0.25rem 0.4rem;
        font-size: 0.62rem;
        font-weight: 500;
        border-radius: 4px;
        cursor: pointer;
        transition: var(--transition);
        border: 1px solid var(--border-color);
        background: var(--bg-secondary);
        color: var(--text-primary);
        text-align: left;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    
    .tag-option-btn:hover {
        border-color: var(--primary-color);
        background: var(--primary-light);
        color: white;
    }
    
    .tag-option-btn.selected {
        border-color: var(--primary-color);
        background: var(--primary-color);
        color: white;
    }
    
    .tag-option-btn.needs { border-left: 3px solid #10b981; }
    .tag-option-btn.flexibleneed { border-left: 3px solid #60a5fa; }
    .tag-option-btn.wants { border-left: 3px solid #f59e0b; }
    .tag-option-btn.savings { border-left: 3px solid #3b82f6; }
    .tag-option-btn.subscription { border-left: 3px solid #8b5cf6; }
    .tag-option-btn.recurring { border-left: 3px solid #06b6d4; }
    .tag-option-btn.onetime, .tag-option-btn.one-time { border-left: 3px solid #6b7280; }
    
    /* Add New Tag Input */
    .add-new-tag-wrapper {
        margin-top: 0.4rem;
        padding-top: 0.4rem;
        border-top: 1px dashed var(--border-color);
    }
    
    .add-new-tag-input {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }
    
    .add-new-tag-input input {
        flex: 1;
        padding: 0.25rem 0.4rem;
        font-size: 0.62rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--bg-primary);
        color: var(--text-primary);
        min-width: 0;
    }
    
    .add-new-tag-input input::placeholder {
        color: var(--text-muted);
        font-style: italic;
    }
    
    .add-new-tag-input input:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.15);
    }
    
    .add-new-tag-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.58rem;
        font-weight: 600;
        border: none;
        border-radius: 4px;
        background: var(--primary-color);
        color: white;
        cursor: pointer;
        white-space: nowrap;
        transition: background 0.2s;
    }
    
    .add-new-tag-btn:hover {
        background: var(--primary-dark);
    }
    
    .add-new-tag-btn:disabled {
        background: var(--text-muted);
        cursor: not-allowed;
    }
    
    /* Note tab */
    .note-input-wrapper {
        margin-top: 0.25rem;
    }
    
    .note-textarea {
        width: 100%;
        min-height: 80px;
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        font-size: 0.72rem;
        font-family: inherit;
        resize: vertical;
        background: var(--bg-secondary);
        color: var(--text-primary);
    }
    
    .note-textarea:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    
    .note-actions {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 0.5rem;
    }
    
    .btn-save-note {
        padding: 0.35rem 0.75rem;
        font-size: 0.68rem;
        font-weight: 500;
        background: var(--success-color);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-save-note:hover {
        background: #059669;
    }
    
    .btn-clear-note {
        padding: 0.35rem 0.75rem;
        font-size: 0.68rem;
        font-weight: 500;
        background: transparent;
        color: var(--text-secondary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-clear-note:hover {
        border-color: var(--danger-color);
        color: var(--danger-color);
    }
    
    /* Transaction note display */
    .transaction-note {
        color: var(--text-secondary);
        font-style: italic;
    }
    
    /* Rules Panel */
    .rules-panel {
        position: fixed;
        top: 0;
        right: -450px;
        width: 450px;
        height: 100vh;
        background: var(--bg-primary);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        transition: right 0.3s ease;
        display: flex;
        flex-direction: column;
    }
    
    .rules-panel.open {
        right: 0;
    }
    
    .rules-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border-color);
        background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
        color: white;
    }
    
    .rules-panel-header h3 {
        font-size: 0.9rem;
        font-weight: 600;
    }
    
    .rules-panel-close {
        background: rgba(255,255,255,0.2);
        border: none;
        color: white;
        width: 28px;
        height: 28px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 1rem;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
    }
    
    .rules-panel-close:hover {
        background: rgba(255,255,255,0.3);
    }
    
    .rules-panel-body {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    
    /* Rule Form */
    .rule-form {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 0.75rem;
        margin-bottom: 1rem;
    }
    
    .rule-form h4 {
        font-size: 0.8rem;
        margin-bottom: 0.5rem;
        color: var(--text-primary);
    }
    
    .rule-form-group {
        margin-bottom: 0.5rem;
    }
    
    .rule-form-group label {
        display: block;
        font-size: 0.7rem;
        font-weight: 500;
        color: var(--text-secondary);
        margin-bottom: 0.2rem;
    }
    
    .rule-form-group input {
        width: 100%;
        padding: 0.4rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.75rem;
    }
    
    .rule-form-group input:focus,
    .rule-form-group select:focus {
        outline: none;
        border-color: var(--primary-color);
    }
    
    .rule-form-group select {
        width: 100%;
        padding: 0.4rem 0.5rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 0.75rem;
        background: white;
    }
    
    /* Multi-Tag Grid */
    .multi-tag-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.5rem;
        margin-bottom: 0.5rem;
    }
    
    @media (max-width: 600px) {
        .multi-tag-grid {
            grid-template-columns: 1fr;
        }
    }
    
    .rule-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
    }
    
    .rule-tag-badge {
        font-size: 0.65rem;
        padding: 0.15rem 0.4rem;
        background: var(--bg-tertiary);
        border-radius: 4px;
        color: var(--text-primary);
        font-weight: 500;
    }
    
    .btn-run-all {
        padding: 0.25rem 0.5rem;
        font-size: 0.65rem;
        font-weight: 600;
        background: linear-gradient(135deg, var(--success-color), #059669);
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.15s ease;
    }
    
    .btn-run-all:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }
    
    .btn-run-all.sweep {
        background: linear-gradient(135deg, #f59e0b, #d97706);
    }
    
    .btn-run-all.sweep:hover {
        box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }
    
    .btn-run-all:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }
    
    .keywords-input-wrapper {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
        padding: 0.35rem;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: white;
        min-height: 36px;
        cursor: text;
    }
    
    .keywords-input-wrapper:focus-within {
        border-color: var(--primary-color);
    }
    
    .keyword-tag {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
        padding: 0.15rem 0.35rem;
        background: var(--primary-color);
        color: white;
        border-radius: 3px;
        font-size: 0.68rem;
        font-weight: 500;
    }
    
    .keyword-tag .remove {
        cursor: pointer;
        opacity: 0.7;
        font-size: 0.8rem;
    }
    
    .keyword-tag .remove:hover {
        opacity: 1;
    }
    
    .keyword-input {
        border: none !important;
        outline: none !important;
        padding: 0.15rem !important;
        font-size: 0.7rem !important;
        flex: 1;
        min-width: 80px;
        background: transparent !important;
    }
    
    .and-connector {
        font-size: 0.6rem;
        color: var(--accent-color);
        font-weight: 600;
        text-transform: uppercase;
    }
    
    .rule-form-hint {
        font-size: 0.65rem;
        color: var(--text-secondary);
        margin-top: 0.15rem;
    }
    
    .preview-section {
        background: var(--bg-tertiary);
        border-radius: 6px;
        padding: 0.5rem;
        margin-top: 0.5rem;
        font-size: 0.7rem;
    }
    
    .preview-count {
        color: var(--primary-color);
        font-weight: 600;
    }
    
    .preview-matches {
        max-height: 200px;
        overflow-y: auto;
        margin-top: 0.3rem;
    }
    
    .preview-match {
        padding: 0.2rem 0;
        border-bottom: 1px solid var(--border-color);
        font-size: 0.65rem;
        color: var(--text-secondary);
    }
    
    .rule-form-actions {
        display: flex;
        gap: 0.35rem;
        margin-top: 0.5rem;
    }
    
    .rule-form-actions button {
        flex: 1;
        padding: 0.4rem 0.6rem;
        border: none;
        border-radius: 4px;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-save-rule {
        background: var(--success-color);
        color: white;
    }
    
    .btn-save-rule:hover {
        background: #059669;
    }
    
    .btn-cancel {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    .btn-cancel:hover {
        background: var(--border-color);
    }
    
    /* Rule List */
    .rules-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .rule-item {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: 0.6rem 0.75rem;
        border-left: 3px solid var(--primary-color);
    }
    
    .rule-item.disabled {
        opacity: 0.5;
        border-left-color: var(--text-light);
    }
    
    .rule-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.3rem;
    }
    
    .rule-category {
        font-weight: 600;
        font-size: 0.8rem;
        color: var(--primary-color);
    }
    
    .rule-actions {
        display: flex;
        gap: 0.25rem;
    }
    
    .rule-actions button {
        padding: 0.15rem 0.35rem;
        border: none;
        border-radius: 3px;
        font-size: 0.65rem;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-edit-rule {
        background: var(--info-color);
        color: white;
    }
    
    .btn-delete-rule {
        background: var(--danger-color);
        color: white;
    }
    
    .btn-toggle-rule {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    .rule-keywords {
        display: flex;
        flex-wrap: wrap;
        gap: 0.2rem;
        align-items: center;
        font-size: 0.7rem;
    }
    
    .rule-keyword {
        background: var(--bg-tertiary);
        padding: 0.1rem 0.3rem;
        border-radius: 3px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.68rem;
    }
    
    .rules-toggle-btn {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        color: var(--primary-color);
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 6px;
        transition: var(--transition);
        background: rgba(99, 102, 241, 0.08);
        border: 1px solid rgba(99, 102, 241, 0.2);
        font-size: 0.7rem;
        font-weight: 600;
    }
    
    .rules-toggle-btn:hover {
        background: rgba(99, 102, 241, 0.15);
        border-color: rgba(99, 102, 241, 0.4);
        transform: translateY(-1px);
    }
    
    .rules-toggle-btn .rules-icon {
        font-size: 0.75rem;
    }
    
    .rules-toggle-btn .rules-text {
        letter-spacing: 0.02em;
    }
    
    .add-cash-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 26px;
        height: 26px;
        background: transparent;
        color: var(--primary-color);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
        border: 1.5px dashed rgba(99, 102, 241, 0.4);
        font-size: 1.1rem;
        font-weight: 300;
        margin-right: 0.3rem;
        position: relative;
    }
    
    .add-cash-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, rgba(99, 102, 241, 0.08), rgba(139, 92, 246, 0.08));
        border-radius: 7px;
        opacity: 0;
        transition: opacity 0.2s ease;
    }
    
    .add-cash-btn:hover {
        border-color: var(--primary-color);
        border-style: solid;
        color: var(--primary-dark);
        transform: scale(1.08);
    }
    
    .add-cash-btn:hover::before {
        opacity: 1;
    }
    
    .add-cash-btn:active {
        transform: scale(0.95);
    }
    
    /* Search Bar */
    .search-container {
        display: flex;
        align-items: center;
        position: relative;
    }
    
    .search-toggle-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 4px;
        transition: var(--transition);
        font-size: 0.85rem;
    }
    
    .search-toggle-btn:hover {
        background: rgba(99, 102, 241, 0.1);
        color: var(--primary-color);
    }
    
    .search-toggle-btn.active {
        color: var(--primary-color);
    }
    
    .search-input-wrapper {
        display: flex;
        align-items: center;
        background: var(--bg-primary);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        overflow: hidden;
        max-width: 0;
        opacity: 0;
        transition: all 0.3s ease;
        margin-right: 0;
    }
    
    .search-input-wrapper.expanded {
        max-width: 200px;
        opacity: 1;
        margin-right: 0.5rem;
    }
    
    .search-input-wrapper:focus-within {
        border-color: var(--primary-color);
        box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
    }
    
    .search-input {
        border: none !important;
        outline: none !important;
        padding: 0.25rem 0.4rem !important;
        font-size: 0.7rem !important;
        background: transparent !important;
        width: 130px;
        color: var(--text-primary);
    }
    
    .search-input::placeholder {
        color: var(--text-light);
    }
    
    .search-clear-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        background: transparent;
        border: none;
        color: var(--text-light);
        cursor: pointer;
        font-size: 0.7rem;
        padding: 0;
        margin-right: 2px;
        border-radius: 50%;
        transition: var(--transition);
    }
    
    .search-clear-btn:hover {
        background: var(--danger-color);
        color: white;
    }
    
    .search-keywords {
        display: flex;
        flex-wrap: wrap;
        gap: 0.2rem;
        align-items: center;
        padding: 0 0.25rem;
    }
    
    .search-keyword-tag {
        display: inline-flex;
        align-items: center;
        gap: 0.15rem;
        padding: 0.1rem 0.3rem;
        background: var(--primary-color);
        color: white;
        border-radius: 3px;
        font-size: 0.6rem;
        font-weight: 500;
    }
    
    .search-keyword-tag .remove {
        cursor: pointer;
        opacity: 0.7;
        font-size: 0.7rem;
    }
    
    .search-keyword-tag .remove:hover {
        opacity: 1;
    }
    
    .search-and-connector {
        font-size: 0.5rem;
        color: var(--accent-color);
        font-weight: 600;
    }
    
    .sweep-toggle-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: var(--warning-color);
        cursor: pointer;
        padding: 0.15rem 0.35rem;
        border-radius: 4px;
        transition: var(--transition);
        background: transparent;
        border: none;
        font-size: 0.85rem;
        margin-left: 0.1rem;
    }
    
    .sweep-toggle-btn:hover {
        background: rgba(245, 158, 11, 0.15);
        transform: scale(1.1);
    }
    
    /* Sweep Panel */
    .sweep-panel {
        position: fixed;
        top: 0;
        right: -450px;
        width: 450px;
        height: 100vh;
        background: var(--bg-primary);
        box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        transition: right 0.3s ease;
        display: flex;
        flex-direction: column;
    }
    
    .sweep-panel.open {
        right: 0;
    }
    
    .sweep-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1rem;
        border-bottom: 1px solid var(--border-color);
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
    }
    
    .sweep-panel-header h3 {
        font-size: 0.9rem;
        font-weight: 600;
    }
    
    .sweep-panel-close {
        background: rgba(255,255,255,0.2);
        border: none;
        color: white;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        font-size: 1rem;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
    }
    
    .sweep-panel-close:hover {
        background: rgba(255,255,255,0.3);
    }
    
    .sweep-panel-body {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }
    
    .sweep-form {
        background: var(--bg-secondary);
        border-radius: 8px;
        padding: 0.75rem;
        margin-bottom: 1rem;
    }
    
    .sweep-form h4 {
        font-size: 0.8rem;
        margin-bottom: 0.5rem;
        color: var(--text-primary);
    }
    
    .sweep-info {
        background: #fef3c7;
        border-left: 3px solid var(--warning-color);
        padding: 0.5rem 0.75rem;
        border-radius: 0 6px 6px 0;
        margin-bottom: 0.75rem;
        font-size: 0.7rem;
        color: #92400e;
    }
    
    .sweep-item {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: 0.6rem 0.75rem;
        border-left: 3px solid var(--warning-color);
        margin-bottom: 0.5rem;
    }
    
    .sweep-item.disabled {
        opacity: 0.5;
        border-left-color: var(--text-light);
    }
    
    .sweep-item.selected {
        border-color: var(--primary-color);
        background: rgba(99, 102, 241, 0.05);
    }
    
    /* Join Rules UI */
    .join-rules-bar {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.35rem 0.5rem;
        background: rgba(99, 102, 241, 0.1);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 4px;
        margin-bottom: 0.5rem;
        font-size: 0.7rem;
    }
    
    .rule-select {
        display: flex;
        align-items: center;
        margin-right: 0.25rem;
    }
    
    .rule-select input[type="checkbox"] {
        width: 12px;
        height: 12px;
        cursor: pointer;
    }
    
    .joined-badge {
        font-size: 0.5rem;
        padding: 0.08rem 0.25rem;
        background: var(--primary-color);
        color: white;
        border-radius: 3px;
        margin-left: 0.2rem;
        font-weight: 600;
    }
    
    .or-connector {
        font-size: 0.55rem;
        font-weight: 600;
        color: #f59e0b;
        background: rgba(245, 158, 11, 0.15);
        padding: 0.08rem 0.2rem;
        border-radius: 3px;
        margin: 0 0.2rem;
    }
    
    .sweep-item-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.3rem;
    }
    
    .sweep-keyword-display {
        font-weight: 600;
        font-size: 0.8rem;
        color: var(--warning-color);
    }
    
    .sweep-actions {
        display: flex;
        gap: 0.25rem;
    }
    
    .sweep-actions button {
        padding: 0.15rem 0.35rem;
        border: none;
        border-radius: 3px;
        font-size: 0.65rem;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .btn-delete-sweep {
        background: var(--danger-color);
        color: white;
    }
    
    .btn-toggle-sweep {
        background: var(--bg-tertiary);
        color: var(--text-primary);
    }
    
    .sweep-keywords {
        display: flex;
        flex-wrap: wrap;
        gap: 0.2rem;
        align-items: center;
        font-size: 0.7rem;
    }
    
    .sweep-keyword {
        background: #fef3c7;
        color: #92400e;
        padding: 0.1rem 0.3rem;
        border-radius: 3px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 0.68rem;
    }
    
    .sweep-stats {
        font-size: 0.68rem;
        color: var(--text-secondary);
        margin-top: 0.25rem;
    }
    
    .btn-save-sweep {
        background: var(--warning-color);
        color: white;
    }
    
    .btn-save-sweep:hover {
        background: #d97706;
    }
    
    /* Category autocomplete */
    .autocomplete-list {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: var(--bg-primary);
        border: 1px solid var(--primary-color);
        border-radius: 4px;
        max-height: 180px;
        overflow-y: auto;
        z-index: 1100;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none;
        margin-top: 2px;
    }
    
    .autocomplete-list.show {
        display: block;
    }
    
    .autocomplete-item {
        padding: 0.35rem 0.5rem;
        font-size: 0.7rem;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .autocomplete-item:hover, .autocomplete-item.selected {
        background: var(--bg-tertiary);
    }
    
    .autocomplete-item .match {
        background: rgba(99, 102, 241, 0.2);
        color: var(--primary-color);
        font-weight: 600;
    }
    
    .input-with-autocomplete {
        position: relative;
    }
    
    /* Panel overlay */
    .panel-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.3);
        z-index: 999;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
    }
    
    .panel-overlay.show {
        opacity: 1;
        visibility: visible;
    }
    
    .transaction-amount {
        font-size: 0.72rem;
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
        white-space: nowrap;
    }
    
    .transaction-amount.expense { color: var(--danger-color); }
    .transaction-amount.income { color: var(--success-color); }
    
    /* Empty/Loading */
    .no-transactions {
        padding: 1.5rem;
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.75rem;
    }
    
    .no-transactions .icon { font-size: 1.25rem; margin-bottom: 0.35rem; }
    
    .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--bg-tertiary);
        border-top-color: var(--primary-color);
        border-radius: 50%;
        animation: spin 0.6s linear infinite;
        margin: 0 auto 0.35rem;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Classification badges for transactions */
    .transaction-badges {
        display: flex;
        gap: 0.25rem;
        flex-wrap: wrap;
    }
    
    .mini-badge {
        padding: 0.05rem 0.2rem;
        border-radius: 2px;
        font-size: 0.55rem;
        font-weight: 500;
        cursor: pointer;
        transition: var(--transition);
    }
    
    .mini-badge:hover {
        opacity: 0.8;
        transform: scale(1.05);
    }
    
    .mini-badge.needs { background: #dbeafe; color: #1d4ed8; }
    .mini-badge.flexibleneed { background: #bfdbfe; color: #1e40af; }
    .mini-badge.wants { background: #fce7f3; color: #be185d; }
    .mini-badge.savings { background: #dcfce7; color: #15803d; }
    .mini-badge.subscription { background: #f3e8ff; color: #7c3aed; }
    .mini-badge.recurring { background: #ccfbf1; color: #0f766e; }
    .mini-badge.one-time, .mini-badge.onetime { background: #f1f5f9; color: #64748b; }
    .mini-badge.income { background: #dcfce7; color: #15803d; }
    
    /* Responsive */
    @media (max-width: 900px) {
        .charts-container { grid-template-columns: 1fr; }
        .pie-analytics-wrapper { flex-direction: row; }
        .pie-chart-card { flex: 1; }
        .analytics-panel { width: 100px; }
        .budget-health-widget { grid-template-columns: 1fr 1fr; }
    }
    
    @media (max-width: 500px) {
        .pie-analytics-wrapper { flex-direction: column; }
        .analytics-panel { width: 100%; flex-direction: row; padding: 0.4rem; }
        .analytics-stats { flex-direction: row; flex-wrap: wrap; gap: 0.25rem; }
        .analytics-stat { flex: 1; min-width: 45%; }
        .analytics-title { display: none; }
    }
    
    @media (max-width: 600px) {
        .transaction-item { grid-template-columns: 1fr; gap: 0.15rem; }
        .budget-health-widget { grid-template-columns: 1fr; }
    }
</style>
{% endblock %}

{% block content %}
<!-- Panel Overlay -->
<div class="panel-overlay" id="panelOverlay" onclick="closeAllPanels()"></div>

<!-- Rules Panel -->
<div class="rules-panel" id="rulesPanel">
    <div class="rules-panel-header">
        <h3>Auto-Tag Rules</h3>
        <button class="rules-panel-close" onclick="closeRulesPanel()">✕</button>
    </div>
    <div class="rules-panel-body">
        <!-- Create New Rule Form -->
        <div class="rule-form" id="ruleForm">
            <h4>Create New Rule</h4>
            <p style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                Set multiple tags at once! Leave fields empty to skip.
            </p>
            <div class="multi-tag-grid">
                <div class="rule-form-group">
                    <label>Category</label>
                    <div class="input-with-autocomplete">
                        <input type="text" id="ruleCategory" placeholder="e.g., Hobby..." autocomplete="off">
                        <div class="autocomplete-list" id="ruleCategoryAutocomplete"></div>
                    </div>
                </div>
                <div class="rule-form-group">
                    <label>Necessity</label>
                    <select id="ruleNecessity">
                        <option value="">— Not set —</option>
                        <option value="Needs">Needs</option>
                        <option value="Flexible Need">Flexible Need</option>
                        <option value="Wants">Wants</option>
                        <option value="Savings">Savings</option>
                    </select>
                </div>
                <div class="rule-form-group">
                    <label>Recurrence</label>
                    <select id="ruleRecurrence">
                        <option value="">— Not set —</option>
                        <option value="Subscription">Subscription</option>
                        <option value="Recurring">Recurring</option>
                        <option value="One-time">One-time</option>
                    </select>
                </div>
            </div>
            <div class="rule-form-group">
                <label>Keywords (ALL must match)</label>
                <div class="keywords-input-wrapper" id="keywordsWrapper" onclick="document.getElementById('keywordInput').focus()">
                    <input type="text" class="keyword-input" id="keywordInput" placeholder="Type and press Enter...">
                </div>
                <div class="rule-form-hint">
                    Press Enter to add each keyword. All keywords must be in the description (AND logic). Case doesn't matter.
                </div>
            </div>
            <div class="preview-section" id="previewSection" style="display: none;">
                <span class="preview-count" id="previewCount">0</span> transactions will be tagged
                <div class="preview-matches" id="previewMatches"></div>
            </div>
            <div class="rule-form-actions">
                <button class="btn-cancel" onclick="resetRuleForm()">Clear</button>
                <button class="btn-save-rule" onclick="saveRule()">Save Rule</button>
            </div>
        </div>
        
        <!-- Existing Rules List -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <h4 style="margin: 0; font-size: 0.8rem;">Existing Rules</h4>
            <button class="btn-run-all" onclick="runAllRules()" title="Apply all rules to transactions">
                ▶ Run All
            </button>
        </div>
        <div class="rules-list" id="rulesList">
            <div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">
                Loading rules...
            </div>
        </div>
    </div>
</div>

<!-- Sweep Panel (Exclusion Rules) -->
<div class="sweep-panel" id="sweepPanel">
    <div class="sweep-panel-header">
        <h3>Sweep Rules</h3>
        <button class="sweep-panel-close" onclick="closeSweepPanel()">✕</button>
    </div>
    <div class="sweep-panel-body">
        <div class="sweep-info">
            <strong>What is Sweep?</strong><br>
            Transactions matching these keywords will be automatically removed — both for existing entries and any future CSV uploads.
        </div>
        
        <!-- Create New Sweep Rule Form -->
        <div class="sweep-form" id="sweepForm">
            <h4>Create Sweep Rule</h4>
            <div class="rule-form-group">
                <label>Rule Title</label>
                <input type="text" class="rule-input" id="sweepRuleTitle" placeholder="e.g., Credit Card Payments, Internal Transfers...">
            </div>
            <div class="rule-form-group">
                <label>Keywords (ALL must match)</label>
                <div class="keywords-input-wrapper" id="sweepKeywordsWrapper" onclick="document.getElementById('sweepKeywordInput').focus()">
                    <input type="text" class="keyword-input" id="sweepKeywordInput" placeholder="Type and press Enter...">
                </div>
                <div class="rule-form-hint">
                    Press Enter to add each keyword. Transactions with ALL these keywords will be swept away. Case doesn't matter.
                </div>
            </div>
            <div class="preview-section" id="sweepPreviewSection" style="display: none;">
                <span class="preview-count" id="sweepPreviewCount">0</span> transactions will be swept
                <div class="preview-matches" id="sweepPreviewMatches"></div>
            </div>
            <div class="rule-form-actions">
                <button class="btn-cancel" onclick="resetSweepForm()">Clear</button>
                <button class="btn-save-sweep" onclick="saveSweepRule()">Sweep & Save</button>
            </div>
        </div>
        
        <!-- Existing Sweep Rules List -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
            <h4 style="margin: 0; font-size: 0.8rem;">Active Sweep Rules</h4>
            <button class="btn-run-all sweep" onclick="runAllSweepRules()" title="Apply all sweep rules to transactions">
                ▶ Run All
            </button>
        </div>
        <p style="font-size: 0.65rem; color: var(--text-secondary); margin-bottom: 0.35rem;">
            Select 2+ rules to join them with OR logic.
        </p>
        <div class="join-rules-bar" id="joinSweepBar" style="display: none;">
            <span id="selectedSweepCount">0</span> selected
            <button class="btn-cancel" onclick="clearSweepSelection()">Clear</button>
            <button class="btn-save-sweep" onclick="joinSelectedSweepRules()">Join</button>
        </div>
        <div class="rules-list" id="sweepRulesList">
            <div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">
                Loading sweep rules...
            </div>
        </div>
    </div>
</div>

<div class="dashboard">
    {% if statistics and statistics.count > 0 %}
    
    <!-- Filter Panel -->
    <div class="filter-panel-overlay" id="filterPanelOverlay" onclick="closeFilterPanel()"></div>
    <div class="filter-panel" id="filterPanel">
        <div class="filter-panel-header">
            <h3>Filter Transactions</h3>
            <button class="filter-panel-close" onclick="closeFilterPanel()">✕</button>
        </div>
        <div class="filter-panel-body">
            <!-- Date Range Section -->
            <div class="filter-section">
                <div class="filter-section-title">Date Range</div>
                <div class="date-range-inputs">
                    <div class="date-input-group">
                        <label>From</label>
                        <input type="date" id="filterStartDate">
                    </div>
                    <div class="date-input-group">
                        <label>To</label>
                        <input type="date" id="filterEndDate">
                    </div>
                </div>
            </div>
            
            <!-- Tag Columns Section -->
            <div class="filter-section">
                <div class="filter-section-title">Tags</div>
                <div class="tag-columns">
                    <!-- Category Column -->
                    <div class="tag-column">
                        <div class="tag-column-title">Category</div>
                        <div class="tag-options" id="categoryTagOptions">
                            <!-- Populated dynamically -->
                        </div>
                    </div>
                    
                    <!-- Necessity Column -->
                    <div class="tag-column">
                        <div class="tag-column-title">Necessity</div>
                        <div class="tag-options" id="necessityTagOptions">
                            <label class="tag-option">
                                <input type="checkbox" value="Needs" onchange="toggleTagFilter('necessity', 'Needs')">
                                <span>Needs</span>
                            </label>
                            <label class="tag-option">
                                <input type="checkbox" value="Flexible Need" onchange="toggleTagFilter('necessity', 'Flexible Need')">
                                <span>Flexible Need</span>
                            </label>
                            <label class="tag-option">
                                <input type="checkbox" value="Wants" onchange="toggleTagFilter('necessity', 'Wants')">
                                <span>Wants</span>
                            </label>
                            <label class="tag-option">
                                <input type="checkbox" value="Savings" onchange="toggleTagFilter('necessity', 'Savings')">
                                <span>Savings</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Recurrence Column -->
                    <div class="tag-column">
                        <div class="tag-column-title">Recurrence</div>
                        <div class="tag-options" id="recurrenceTagOptions">
                            <label class="tag-option">
                                <input type="checkbox" value="Subscription" onchange="toggleTagFilter('recurrence', 'Subscription')">
                                <span>Subscription</span>
                            </label>
                            <label class="tag-option">
                                <input type="checkbox" value="Recurring" onchange="toggleTagFilter('recurrence', 'Recurring')">
                                <span>Recurring</span>
                            </label>
                            <label class="tag-option">
                                <input type="checkbox" value="One-time" onchange="toggleTagFilter('recurrence', 'One-time')">
                                <span>One-time</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Untagged Section -->
            <div class="filter-section">
                <div class="filter-section-title">Show Untagged Only</div>
                <div class="untagged-options">
                    <label class="untagged-option">
                        <input type="checkbox" id="untaggedCategory" onchange="toggleUntaggedFilter('category')">
                        <span>Missing Category</span>
                    </label>
                    <label class="untagged-option">
                        <input type="checkbox" id="untaggedNecessity" onchange="toggleUntaggedFilter('necessity')">
                        <span>Missing Necessity</span>
                        <span class="untagged-hint">(excludes Income)</span>
                    </label>
                    <label class="untagged-option">
                        <input type="checkbox" id="untaggedRecurrence" onchange="toggleUntaggedFilter('recurrence')">
                        <span>Missing Recurrence</span>
                    </label>
                </div>
            </div>
        </div>
        <div class="filter-panel-footer">
            <button class="btn-reset" onclick="resetPanelFilters()">Reset</button>
            <button class="btn-apply" onclick="applyPanelFilters()">Apply Filters</button>
        </div>
    </div>
    
    <!-- Charts Row -->
    <div class="charts-container">
        <!-- Normal Mode: Line Chart -->
        <div class="chart-card line-chart-card" id="lineChartCard">
            <h3 class="chart-title">
                 Spending Over Time <span class="chart-period-label" id="chartPeriodLabel"></span>
                <span class="line-breakdown-selector" id="lineBreakdownSelector" onclick="toggleLineBreakdownMenu(event)">
                    <span id="lineBreakdownLabel">Total</span>
                    <span class="dropdown-arrow">▾</span>
                </span>
                <div class="line-breakdown-menu" id="lineBreakdownMenu">
                    <div class="line-breakdown-option" data-value="total" onclick="selectLineBreakdown('total', 'Total', event)">Total Spending</div>
                    <div class="line-breakdown-option" data-value="category" onclick="selectLineBreakdown('category', 'Category', event)">By Category</div>
                    <div class="line-breakdown-option" data-value="necessity" onclick="selectLineBreakdown('necessity', 'Needs/Wants', event)">By Needs/Wants</div>
                    <div class="line-breakdown-option" data-value="recurrence" onclick="selectLineBreakdown('recurrence', 'Recurrence', event)">By Recurrence</div>
                    <div class="line-breakdown-divider"></div>
                    <div class="line-breakdown-option line-toggle-option" data-value="average" onclick="toggleLineOption('average', event)">
                        <span class="toggle-check" id="avgCheck">✓</span> Average
                    </div>
                    <div class="line-breakdown-option line-toggle-option" data-value="median" onclick="toggleLineOption('median', event)">
                        <span class="toggle-check" id="medianCheck">✓</span> Median
                    </div>
                </div>
            </h3>
            <div class="line-chart-container">
                <canvas id="spendingLineChart"></canvas>
            </div>
        </div>
        
        <!-- Budget Mode: Budget Stats + Personal Analysis + Over Budget Status -->
        <div class="budget-mode-row" id="budgetModeRow">
            <!-- Budget Stats (Left) -->
            <div class="budget-stats-panel">
                <h3 class="budget-stats-title">Budget Stats</h3>
                <div class="budget-stat income-stat">
                    <span class="budget-stat-label">Total Income</span>
                    <span class="budget-stat-value positive" id="budgetIncome">$0.00</span>
                </div>
                <div class="budget-stat spending-power-stat">
                    <span class="budget-stat-label">Spending Power</span>
                    <span class="budget-stat-value" id="budgetSpendingPower">$0.00</span>
                </div>
                <div class="budget-stat discretionary-stat">
                    <span class="budget-stat-label">Discretionary</span>
                    <span class="budget-stat-value" id="budgetDiscretionary">$0.00</span>
                </div>
            </div>
            
            <!-- Personal Analysis (Middle) -->
            <div class="personal-analysis-column">
                <div class="personal-analysis-card">
                    <div class="personal-analysis-header">
                        <div class="personal-analysis-title">
                            Personal Analysis
                        </div>
                        <span class="personal-analysis-save-status" id="analysisSaveStatus"></span>
                    </div>
                    <div class="personal-analysis-content">
                        <textarea 
                            class="personal-analysis-textarea" 
                            id="personalAnalysisText"
                            placeholder="Write your notes for this period...

• What went well?
• Areas to improve?
• Unexpected expenses?"
                        ></textarea>
                    </div>
                </div>
            </div>
            
            <!-- Over Budget Status (Right of Personal Analysis) -->
            <div class="budget-status-column">
                <div class="budget-status-card" id="budgetStatusCard">
                    <div class="no-budget-state">
                        <h3>No Budget Set</h3>
                        <p>Enter a budget amount</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="pie-analytics-wrapper">
            <div class="chart-card pie-chart-card">
                <h3 class="chart-title">
                     Breakdown: 
                    <span class="breakdown-selector" id="breakdownSelector" onclick="toggleBreakdownMenu(event)">
                        <span id="breakdownLabel">Category</span>
                        <span class="dropdown-arrow">▾</span>
                    </span>
                    <div class="breakdown-menu" id="breakdownMenu">
                        <div class="breakdown-option" data-value="category" onclick="selectBreakdown('category', 'Category', event)">Category</div>
                        <div class="breakdown-option" data-value="necessity" onclick="selectBreakdown('necessity', 'Needs/Wants', event)">Needs/Wants</div>
                        <div class="breakdown-option" data-value="recurrence" onclick="selectBreakdown('recurrence', 'Recurrence', event)">Recurrence</div>
                        <div class="breakdown-option" data-value="transactions" onclick="selectBreakdown('transactions', 'Transactions', event)">Transactions</div>
                        <div class="breakdown-option" data-value="bank" onclick="selectBreakdown('bank', 'Bank', event)">Bank</div>
                    </div>
                </h3>
                <div class="pie-chart-container">
                    <canvas id="spendingPieChart"></canvas>
                </div>
            </div>
            
            <div class="analytics-panel">
                <h3 class="analytics-title"> Stats</h3>
                <div class="analytics-stats">
                    <div class="analytics-stat">
                        <span class="analytics-label">Average</span>
                        <span class="analytics-value" id="analyticsAvg">${{ "%.2f"|format(statistics.mean if statistics.mean else 0) }}</span>
                    </div>
                    <div class="analytics-stat">
                        <span class="analytics-label">Median</span>
                        <span class="analytics-value" id="analyticsMedian">${{ "%.2f"|format(statistics.median if statistics.median else 0) }}</span>
                    </div>
                    <div class="analytics-stat total-stat">
                        <span class="analytics-label">Total Spent</span>
                        <span class="analytics-value total-value" id="analyticsTotal">${{ "%.2f"|format(statistics.total) }}</span>
                    </div>
                    <div class="analytics-stat count-stat">
                        <span class="analytics-label">Transactions</span>
                        <span class="analytics-value count-value" id="analyticsCount">{{ statistics.count }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Transactions Section -->
    <div class="transactions-section">
        <div class="transactions-header">
            <h3><span id="transactionsTitle">All Transactions</span></h3>
            <div class="transactions-summary">
                <button class="add-cash-btn" onclick="openCashTransactionModal()" title="Add Cash Transaction">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <div class="search-container">
                    <div class="search-input-wrapper" id="searchInputWrapper">
                        <div class="search-keywords" id="searchKeywords"></div>
                        <input type="text" class="search-input" id="searchInput" placeholder="Search keywords...">
                        <button class="search-clear-btn" id="searchClearBtn" onclick="clearSearch()" style="display: none;">✕</button>
                    </div>
                    <button class="search-toggle-btn" id="searchToggleBtn" onclick="toggleSearchBar()" title="Search transactions">🔍</button>
                </div>
                <button class="rules-toggle-btn" onclick="toggleRulesPanel()" title="Auto-tag Rules">
                    <span class="rules-icon">⚙</span><span class="rules-text">Rules</span>
                </button>
                <button class="sweep-toggle-btn" onclick="toggleSweepPanel()" title="Sweep: Remove transactions matching keywords">
                    🧹
                </button>
            </div>
            <!-- Hidden elements for JS compatibility -->
            <span id="summaryCount" style="display:none;">{{ statistics.count }}</span>
            <span id="summaryAvg" style="display:none;">${{ "%.2f"|format(statistics.mean if statistics.mean else 0) }}</span>
            <span id="summaryMedian" style="display:none;">${{ "%.2f"|format(statistics.median if statistics.median else 0) }}</span>
            <span id="summarySpent" style="display:none;">${{ "%.2f"|format(statistics.total) }}</span>
        </div>
        <div class="transactions-list" id="transactionsList">
            <div class="no-transactions">
                <div class="spinner"></div>
                <p>Loading...</p>
            </div>
        </div>
    </div>
    
    <!-- Cash Transaction Modal -->
    <div class="cash-modal" id="cashModal" onclick="if(event.target === this) closeCashModal()">
        <div class="cash-modal-content">
            <div class="cash-modal-header">
                <h3>New Transaction</h3>
                <button class="cash-modal-close" onclick="closeCashModal()">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div class="cash-modal-body">
                <form id="cashTransactionForm" onsubmit="saveCashTransaction(event)">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Date *</label>
                            <input type="date" id="cashDate" required>
                        </div>
                        <div class="form-group">
                            <label>Amount *</label>
                            <input type="number" id="cashAmount" placeholder="-0.00" step="0.01" required>
                            <div class="form-hint">Negative for expense, positive for income</div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Description *</label>
                        <input type="text" id="cashDescription" placeholder="e.g., Coffee shop, Grocery store" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Category</label>
                            <input type="text" id="cashCategory" placeholder="e.g., Food & Drink, Shopping" list="categoryList">
                            <datalist id="categoryList"></datalist>
                        </div>
                        <div class="form-group">
                            <label>Bank/Source</label>
                            <input type="text" id="cashBank" value="Cash" placeholder="Cash">
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Necessity</label>
                            <select id="cashNecessity">
                                <option value="Unknown">-- Select --</option>
                                <option value="Needs">Needs</option>
                                <option value="Wants">Wants</option>
                                <option value="Savings">Savings</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Recurrence</label>
                            <select id="cashRecurrence">
                                <option value="One-time">One-time</option>
                                <option value="Recurring">Recurring</option>
                                <option value="Subscription">Subscription</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Note (Optional)</label>
                        <input type="text" id="cashNote" placeholder="Additional notes...">
                    </div>
                    <div class="cash-modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeCashModal()">Cancel</button>
                        <button type="submit" class="btn btn-primary">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round">
                                <line x1="12" y1="5" x2="12" y2="19"></line>
                                <line x1="5" y1="12" x2="19" y2="12"></line>
                            </svg>
                            Add Transaction
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Recurring Expenses Modal -->
    <div class="recurring-modal" id="recurringModal" onclick="if(event.target === this) closeRecurringModal()">
        <div class="recurring-modal-content">
            <div class="recurring-modal-header">
                <h3>Recurring Expenses</h3>
                <button class="recurring-modal-close" onclick="closeRecurringModal()">✕</button>
            </div>
            <div class="recurring-modal-body">
                <!-- Add New Recurring Expense Form -->
                <div class="recurring-form">
                    <h4>Add Recurring Expense</h4>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="recurringName" placeholder="e.g., Rent, Car Insurance">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="number" id="recurringAmount" placeholder="0.00" step="0.01" min="0">
                        </div>
                        <div class="form-group">
                            <label>Frequency</label>
                            <select id="recurringFrequency">
                                <option value="monthly">Monthly</option>
                                <option value="weekly">Weekly</option>
                            </select>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <input type="text" id="recurringCategory" placeholder="e.g., Housing, Transportation, Insurance">
                    </div>
                    <div class="form-group">
                        <label>Link to Transactions (Optional)</label>
                        <div class="keywords-wrapper" id="recurringKeywordsWrapper" onclick="document.getElementById('recurringKeywordInput').focus()">
                            <input type="text" class="keyword-input" id="recurringKeywordInput" placeholder="Type keyword and press Enter...">
                        </div>
                        <div class="form-hint">Keywords help auto-detect this expense. All keywords must match (AND logic). Matching transactions will be tagged as "Recurring".</div>
                    </div>
                    <div class="preview-box" id="recurringPreview" style="display: none;">
                        <span class="count" id="recurringPreviewCount">0</span> transaction(s) will be linked
                        <div class="preview-list" id="recurringPreviewList"></div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                        <button class="btn btn-secondary" onclick="resetRecurringForm()">Clear</button>
                        <button class="btn btn-primary" onclick="saveRecurringExpense()">💾 Save Expense</button>
                    </div>
                </div>
                
                <!-- Recurring Expenses List -->
                <div id="recurringListContainer">
                    <div class="loading-state" style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">
                        Loading...
                    </div>
                </div>
                
                <!-- Totals Summary -->
                <div class="recurring-totals" id="recurringTotals" style="display: none;">
                    <div class="recurring-total-card">
                        <div class="recurring-total-label">Weekly Total</div>
                        <div class="recurring-total-value" id="weeklyTotal">$0.00</div>
                    </div>
                    <div class="recurring-total-card">
                        <div class="recurring-total-label">Monthly Total</div>
                        <div class="recurring-total-value" id="monthlyTotal">$0.00</div>
                    </div>
                    <div class="recurring-total-card">
                        <div class="recurring-total-label">Monthly Equivalent</div>
                        <div class="recurring-total-value" id="monthlyEquivalent">$0.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    {% else %}
    <div class="empty-state">
        <h3>No Transactions Yet</h3>
        <p>Upload your first CSV file to start tracking!</p>
        <a href="{{ url_for('upload') }}" class="btn btn-primary">Upload CSV</a>
    </div>
    {% endif %}
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script>
    Chart.defaults.font.family = "'Inter', -apple-system, sans-serif";
    Chart.defaults.font.size = 10;
    Chart.defaults.color = '#64748b';
    
    const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#06b6d4', '#3b82f6'];
    const categoryColors = {{ category_colors|tojson|safe if category_colors else '{}' }};
    
    let currentPeriod = 'days';
    let currentPieFilter = 'category';
    let currentLineBreakdown = 'total'; // 'total', 'category', 'necessity', 'recurrence'
    let showAverage = false;
    let showMedian = false;
    let currentSort = 'amount-desc';  // Default: sort by largest expense
    let lineChart = null;
    let periodOffset = 0; // For navigation: 0 = current, -1 = previous, 1 = next, etc.
    let pieChart = null;
    let allTransactions = [];
    let displayedTransactions = [];
    
    // ============ BUDGET MODE STATE ============
    let budgetMode = false;
    let currentBudget = 0;
    let budgetTimeframe = localStorage.getItem('spendsight_budgetTimeframe') || 'monthly';
    let budgetData = null;
    let recurringExpenses = [];
    let newRecurringKeywords = [];
    let budgetModeInitialized = false; // Track if we've toggled to budget mode at least once
    let currentPeriodKey = '';
    let analysisSaveTimeout = null;
    
    // ============ BUDGET MODE FUNCTIONS ============
    
    // Store the dashboard state before entering budget mode
    let savedDashboardPeriod = null;
    let savedDashboardOffset = null;
    
    // Handle budget mode toggle (called from base.html)
    window.handleBudgetModeToggle = function() {
        if (!budgetMode) {
            // Entering budget mode - save current dashboard state
            savedDashboardPeriod = currentPeriod;
            savedDashboardOffset = periodOffset;
            budgetModeInitialized = true;
        }
        
        budgetMode = !budgetMode;
        updateBudgetModeUI();
        
        // Update navbar link active state
        const budgetLink = document.getElementById('budgetLink');
        const dashboardLink = document.getElementById('dashboardLink');
        if (budgetLink) budgetLink.classList.toggle('active', budgetMode);
        if (dashboardLink) dashboardLink.classList.toggle('active', !budgetMode);
        
        if (budgetMode) {
            // Save current timeframe to ensure sync
            saveTimeframeToStorage();
            loadBudgetData();
            loadRecurringExpenses();
        } else {
            // Returning to dashboard - restore the saved state if it was changed
            if (savedDashboardPeriod !== null && savedDashboardOffset !== null) {
                // The chart should already be showing the same view, just unhide it
                // No need to change anything - the line chart maintains its state
            }
        }
    };
    
    function updateBudgetModeUI() {
        const lineChartCard = document.getElementById('lineChartCard');
        const budgetModeRow = document.getElementById('budgetModeRow');
        const budgetInputSection = document.getElementById('budgetInputSection');
        
        if (budgetMode) {
            lineChartCard.style.display = 'none';
            budgetModeRow.classList.add('active');
            if (budgetInputSection) budgetInputSection.style.display = 'flex';
            loadPersonalAnalysis();
        } else {
            lineChartCard.style.display = '';
            budgetModeRow.classList.remove('active');
            if (budgetInputSection) budgetInputSection.style.display = 'none';
        }
    }
    
    // ============ PERSONAL ANALYSIS ============
    
    function getVisibleDateRange() {
        // Get the current visible date range from the line chart
        const now = new Date();
        let startDate, endDate;
        
        if (lineChart && lineChart.selectedKeys && lineChart.selectedKeys.length > 0) {
            const keys = lineChart.selectedKeys;
            if (currentPeriod === 'days') {
                startDate = new Date(keys[0] + 'T12:00:00');
                endDate = new Date(keys[keys.length - 1] + 'T12:00:00');
            } else if (currentPeriod === 'weeks') {
                startDate = new Date(keys[0] + 'T12:00:00');
                const lastWeekEnd = new Date(keys[keys.length - 1] + 'T12:00:00');
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                endDate = lastWeekEnd;
            } else if (currentPeriod === 'months') {
                const [year, month] = keys[0].split('-');
                startDate = new Date(parseInt(year), parseInt(month) - 1, 1);
                const lastMonth = keys[keys.length - 1];
                const [ly, lm] = lastMonth.split('-');
                endDate = new Date(parseInt(ly), parseInt(lm), 0);
            } else if (currentPeriod === 'years') {
                startDate = new Date(parseInt(keys[0]), 0, 1);
                endDate = new Date(parseInt(keys[keys.length - 1]), 11, 31);
            }
        } else {
            // Default to current month
            startDate = new Date(now.getFullYear(), now.getMonth(), 1);
            endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        }
        
        return { startDate, endDate };
    }
    
    function getPeriodKey() {
        // Generate a unique key for the current period based on budget timeframe
        const { startDate } = getVisibleDateRange();
        if (budgetTimeframe === 'weekly') {
            // Get the Sunday of the week
            const sunday = new Date(startDate);
            sunday.setDate(startDate.getDate() - startDate.getDay());
            return `weekly_${sunday.toISOString().split('T')[0]}`;
        } else {
            const year = startDate.getFullYear();
            const month = String(startDate.getMonth() + 1).padStart(2, '0');
            return `monthly_${year}-${month}`;
        }
    }
    
    async function loadPersonalAnalysis() {
        currentPeriodKey = getPeriodKey();
        
        try {
            const response = await fetch(`/api/period-notes/${encodeURIComponent(currentPeriodKey)}`);
            const data = await response.json();
            
            const textarea = document.getElementById('personalAnalysisText');
            if (textarea) {
                textarea.value = data.content || '';
            }
        } catch (error) {
            console.error('Error loading personal analysis:', error);
        }
    }
    
    async function savePersonalAnalysis() {
        const textarea = document.getElementById('personalAnalysisText');
        const statusEl = document.getElementById('analysisSaveStatus');
        
        if (!textarea || !currentPeriodKey) return;
        
        const content = textarea.value;
        
        // Show saving status
        statusEl.textContent = 'Saving...';
        statusEl.className = 'personal-analysis-save-status visible';
        
        try {
            const response = await fetch(`/api/period-notes/${encodeURIComponent(currentPeriodKey)}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ content })
            });
            
            if (response.ok) {
                statusEl.textContent = '✓ Saved';
                statusEl.className = 'personal-analysis-save-status visible saved';
                setTimeout(() => {
                    statusEl.className = 'personal-analysis-save-status';
                }, 2000);
            } else {
                throw new Error('Save failed');
            }
        } catch (error) {
            console.error('Error saving personal analysis:', error);
            statusEl.textContent = '✕ Error';
            statusEl.className = 'personal-analysis-save-status visible';
        }
    }
    
    function setupPersonalAnalysis() {
        const textarea = document.getElementById('personalAnalysisText');
        if (!textarea) return;
        
        textarea.addEventListener('input', function() {
            if (analysisSaveTimeout) clearTimeout(analysisSaveTimeout);
            
            const statusEl = document.getElementById('analysisSaveStatus');
            statusEl.textContent = 'Typing...';
            statusEl.className = 'personal-analysis-save-status visible';
            
            analysisSaveTimeout = setTimeout(() => savePersonalAnalysis(), 1000);
        });
        
        textarea.addEventListener('blur', function() {
            if (analysisSaveTimeout) clearTimeout(analysisSaveTimeout);
            savePersonalAnalysis();
        });
    }
    
    function initBudgetInput() {
        // Load saved budgets from localStorage (separate for monthly and weekly)
        budgetTimeframe = localStorage.getItem('spendsight_budgetTimeframe') || 'monthly';
        currentBudget = parseFloat(localStorage.getItem(`spendsight_budget_${budgetTimeframe}`)) || 0;
        
        const budgetInput = document.getElementById('budgetInput');
        if (budgetInput && currentBudget > 0) {
            budgetInput.value = currentBudget;
        }
        
        // Set the correct timeframe button as active
        document.querySelectorAll('.budget-timeframe-toggle button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.budgetTf === budgetTimeframe);
        });
        
        // Setup event listeners for M/W toggle
        document.querySelectorAll('.budget-timeframe-toggle button').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.budget-timeframe-toggle button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                budgetTimeframe = this.dataset.budgetTf;
                localStorage.setItem('spendsight_budgetTimeframe', budgetTimeframe);
                
                // Sync Dashboard period with budget timeframe:
                // M (monthly) → Weeks view
                // W (weekly) → Days view
                const targetPeriod = budgetTimeframe === 'monthly' ? 'weeks' : 'days';
                localStorage.setItem('spendsight_dashboardPeriod', targetPeriod);
                localStorage.setItem('spendsight_currentPeriod', targetPeriod);
                localStorage.setItem('spendsight_periodOffset', '0');
                
                // Update the Days/Weeks toggle buttons
                document.querySelectorAll('.time-toggle button').forEach(b => {
                    b.classList.toggle('active', b.dataset.period === targetPeriod);
                });
                currentPeriod = targetPeriod;
                periodOffset = 0;
                updateLineChart();
                
                // Load the budget for this timeframe
                currentBudget = parseFloat(localStorage.getItem(`spendsight_budget_${budgetTimeframe}`)) || 0;
                const input = document.getElementById('budgetInput');
                if (input) {
                    input.value = currentBudget > 0 ? currentBudget : '';
                }
                
                if (budgetMode) {
                    renderBudgetStatus();
                    loadPersonalAnalysis();
                }
                
                // Sync transactions to the new visible timeframe
                syncTransactionsToTimeframe();
            });
        });
        
        // Setup Personal Analysis textarea
        setupPersonalAnalysis();
        
        // Allow pressing Enter to save budget
        if (budgetInput) {
            budgetInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    saveBudget();
                }
            });
        }
        
        // Check if URL has ?budget=1 parameter
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('budget') === '1') {
            // Wait for charts to initialize first, then toggle budget mode
            setTimeout(() => {
                budgetMode = true;
                updateBudgetModeUI();
                
                // Update navbar link active state
                const budgetLink = document.getElementById('budgetLink');
                const dashboardLink = document.getElementById('dashboardLink');
                if (budgetLink) budgetLink.classList.add('active');
                if (dashboardLink) dashboardLink.classList.remove('active');
                
                loadBudgetData();
                loadRecurringExpenses();
                
                // Clean the URL
                window.history.replaceState({}, document.title, window.location.pathname);
            }, 200);
        }
    }
    
    function saveBudget() {
        const input = document.getElementById('budgetInput');
        const value = parseFloat(input.value.replace(/[^0-9.]/g, '')) || 0;
        currentBudget = value;
        // Save to the correct key based on current timeframe (monthly or weekly)
        localStorage.setItem(`spendsight_budget_${budgetTimeframe}`, value);
        
        // Flash confirmation
        const btn = document.querySelector('.budget-set-btn');
        if (btn) {
            btn.style.background = 'rgba(16, 185, 129, 1)';
            btn.textContent = '✓';
            setTimeout(() => {
                btn.style.background = '';
            }, 1000);
        }
        
        if (budgetMode) {
            renderBudgetStatus();
        }
    }
    
    async function loadBudgetData() {
        // Get the current timeframe dates from the line chart
        let startDate, endDate;
        const now = new Date();
        
        if (lineChart && lineChart.selectedKeys && lineChart.selectedKeys.length > 0) {
            const keys = lineChart.selectedKeys;
            if (currentPeriod === 'days') {
                startDate = keys[0];
                endDate = keys[keys.length - 1];
            } else if (currentPeriod === 'weeks') {
                startDate = keys[0];
                const lastWeekEnd = new Date(keys[keys.length - 1] + 'T12:00:00');
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                endDate = lastWeekEnd.toISOString().split('T')[0];
            } else if (currentPeriod === 'months') {
                startDate = keys[0] + '-01';
                const lastMonth = keys[keys.length - 1];
                const [year, month] = lastMonth.split('-');
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                endDate = `${lastMonth}-${lastDay}`;
            } else if (currentPeriod === 'years') {
                startDate = `${keys[0]}-01-01`;
                endDate = `${keys[keys.length - 1]}-12-31`;
            }
        } else {
            // Default to current month
            startDate = new Date(now.getFullYear(), now.getMonth(), 1).toISOString().split('T')[0];
            endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0).toISOString().split('T')[0];
        }
        
        try {
            const response = await fetch(`/api/budget-data?start_date=${startDate}&end_date=${endDate}`);
            budgetData = await response.json();
            renderBudgetStats();
            renderBudgetStatus();
        } catch (error) {
            console.error('Error loading budget data:', error);
        }
    }
    
    function renderBudgetStats() {
        if (!budgetData) return;
        
        const income = budgetData.total_income || 0;
        const recurringTotal = budgetData.recurring_total || 0;
        const needsTotal = budgetData.needs_total || 0;
        
        const spendingPower = income - recurringTotal;
        const discretionary = income - needsTotal;
        
        const incomeEl = document.getElementById('budgetIncome');
        const spendingPowerEl = document.getElementById('budgetSpendingPower');
        const discretionaryEl = document.getElementById('budgetDiscretionary');
        
        if (incomeEl) incomeEl.textContent = formatCurrency(income);
        if (spendingPowerEl) {
            spendingPowerEl.textContent = formatCurrency(spendingPower);
            spendingPowerEl.className = 'budget-stat-value ' + (spendingPower >= 0 ? 'positive' : 'negative');
        }
        if (discretionaryEl) {
            discretionaryEl.textContent = formatCurrency(discretionary);
            discretionaryEl.className = 'budget-stat-value ' + (discretionary >= 0 ? 'positive' : 'negative');
        }
    }
    
    function renderBudgetStatus() {
        const container = document.getElementById('budgetStatusCard');
        
        if (!currentBudget || currentBudget <= 0) {
            container.innerHTML = `
                <div class="no-budget-state">
                    <h3>No Budget Set</h3>
                    <p>Enter a budget amount</p>
                </div>
            `;
            container.className = 'budget-status-card';
            return;
        }
        
        const spent = budgetData?.total_spent || 0;
        const percentage = (spent / currentBudget) * 100;
        const remaining = currentBudget - spent;
        
        let status, statusIcon, statusText, statusMessage;
        
        if (percentage <= 75) {
            status = 'passed';
            statusIcon = '';
            statusText = 'On Track!';
            statusMessage = `${formatCurrency(remaining)} left`;
        } else if (percentage <= 100) {
            status = 'warning';
            statusIcon = '';
            statusText = 'Getting Close';
            statusMessage = `Only ${formatCurrency(remaining)} left`;
        } else {
            status = 'failed';
            statusIcon = '';
            statusText = 'Over Budget!';
            statusMessage = `${formatCurrency(Math.abs(remaining))} over`;
        }
        
        const periodLabel = budgetTimeframe === 'weekly' ? 'Weekly' : 'Monthly';
        const progressWidth = Math.min(percentage, 100);
        
        container.className = `budget-status-card ${status}`;
        container.innerHTML = `
            <div class="budget-status-compact">
                <div class="budget-status-main">
                    <span class="budget-status-icon-compact">${statusIcon}</span>
                    <div class="budget-status-info">
                        <div class="budget-status-label">${statusText}</div>
                        <div class="budget-status-amount ${status === 'failed' ? 'negative' : (status === 'passed' ? 'positive' : '')}">${formatCurrency(spent)}</div>
                        <div class="budget-status-limit">of ${formatCurrency(currentBudget)} ${periodLabel}</div>
                    </div>
                </div>
                
                <div class="budget-progress-compact">
                    <div class="budget-progress-bar">
                        <div class="budget-progress-fill ${status}" style="width: ${progressWidth}%"></div>
                    </div>
                    <div class="budget-progress-stats">
                        <span class="budget-percentage ${status}">${percentage.toFixed(1)}%</span>
                        <span class="budget-remaining-compact ${remaining >= 0 ? '' : 'negative'}">
                            ${remaining >= 0 ? '+' : '-'}${formatCurrency(Math.abs(remaining))}
                        </span>
                    </div>
                </div>
                
                <div class="budget-status-message">${statusMessage}</div>
            </div>
        `;
    }
    
    function formatCurrency(amount) {
        return '$' + Math.abs(amount).toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    }
    
    // ============ CASH TRANSACTION FUNCTIONS ============
    
    function openCashTransactionModal() {
        const modal = document.getElementById('cashModal');
        modal.classList.add('show');
        
        // Set default date to today
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('cashDate').value = today;
        
        // Populate category datalist with existing categories
        populateCategoryDatalist();
    }
    
    function closeCashModal() {
        document.getElementById('cashModal').classList.remove('show');
        document.getElementById('cashTransactionForm').reset();
        document.getElementById('cashBank').value = 'Cash';
    }
    
    function populateCategoryDatalist() {
        const datalist = document.getElementById('categoryList');
        const categories = new Set();
        
        // Get categories from all_transactions if available
        if (typeof allTransactions !== 'undefined') {
            allTransactions.forEach(t => {
                if (t.category && t.category !== 'Other') {
                    categories.add(t.category);
                }
            });
        }
        
        // Add common categories
        ['Food & Drink', 'Shopping', 'Groceries', 'Entertainment', 'Transportation', 
         'Gas', 'Bills & Utilities', 'Health', 'Travel', 'Income'].forEach(c => categories.add(c));
        
        datalist.innerHTML = Array.from(categories).sort().map(c => 
            `<option value="${escapeHtml(c)}">`
        ).join('');
    }
    
    async function saveCashTransaction(event) {
        event.preventDefault();
        
        const date = document.getElementById('cashDate').value;
        const amount = parseFloat(document.getElementById('cashAmount').value);
        const description = document.getElementById('cashDescription').value.trim();
        const category = document.getElementById('cashCategory').value.trim() || 'Other';
        const bank = document.getElementById('cashBank').value.trim() || 'Cash';
        const necessity = document.getElementById('cashNecessity').value;
        const recurrence = document.getElementById('cashRecurrence').value;
        const note = document.getElementById('cashNote').value.trim();
        
        if (!date || isNaN(amount) || !description) {
            alert('Please fill in all required fields');
            return;
        }
        
        try {
            const response = await fetch('/api/transactions/add-cash', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    date: date,
                    amount: amount,
                    description: description,
                    category: category,
                    bank: bank,
                    necessity: necessity,
                    recurrence: recurrence,
                    note: note
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                closeCashModal();
                // Reload transactions to show the new one
                loadTransactions();
                // Show success feedback
                showToast('Transaction added successfully!');
            } else {
                alert('Error: ' + (result.error || 'Failed to add transaction'));
            }
        } catch (error) {
            alert('Error adding transaction: ' + error.message);
        }
    }
    
    function showToast(message) {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--success-color, #10b981);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideUp 0.3s ease;
        `;
        toast.textContent = message;
        document.body.appendChild(toast);
        
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            setTimeout(() => toast.remove(), 300);
        }, 2500);
    }
    
    // ============ RECURRING EXPENSES FUNCTIONS ============
    
    function openRecurringModal() {
        document.getElementById('recurringModal').classList.add('show');
        loadRecurringExpenses();
    }
    
    function closeRecurringModal() {
        document.getElementById('recurringModal').classList.remove('show');
    }
    
    async function loadRecurringExpenses() {
        try {
            const response = await fetch('/api/recurring-expenses');
            const data = await response.json();
            recurringExpenses = data.expenses || [];
            renderRecurringExpenses();
            
            // Update totals
            if (data.weekly_total !== undefined) {
                document.getElementById('weeklyTotal').textContent = formatCurrency(data.weekly_total);
                document.getElementById('monthlyTotal').textContent = formatCurrency(data.monthly_total);
                document.getElementById('monthlyEquivalent').textContent = formatCurrency(data.monthly_equivalent);
                document.getElementById('recurringTotals').style.display = recurringExpenses.length > 0 ? 'grid' : 'none';
            }
        } catch (error) {
            console.error('Error loading recurring expenses:', error);
        }
    }
    
    function renderRecurringExpenses() {
        const container = document.getElementById('recurringListContainer');
        
        if (recurringExpenses.length === 0) {
            container.innerHTML = `<div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">No recurring expenses yet</div>`;
            return;
        }
        
        container.innerHTML = `<div class="recurring-list">${recurringExpenses.map(expense => `
            <div class="recurring-item ${expense.enabled ? '' : 'disabled'}">
                <div class="recurring-info">
                    <div class="recurring-details">
                        <div class="recurring-name">${escapeHtml(expense.name)}</div>
                        <div class="recurring-meta">
                            <span class="recurring-frequency">${expense.frequency}</span>
                            <span>${escapeHtml(expense.category || 'Other')}</span>
                        </div>
                        ${expense.keywords && expense.keywords.length > 0 ? `
                            <div class="recurring-keywords">
                                ${expense.keywords.map(kw => `<span class="recurring-keyword">${escapeHtml(kw)}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                    <span class="recurring-amount">-${formatCurrency(expense.amount)}</span>
                    <div class="recurring-actions">
                        <button onclick="toggleRecurringExpense('${expense.id}')" title="${expense.enabled ? 'Disable' : 'Enable'}">
                            ${expense.enabled ? '✓' : '○'}
                        </button>
                        <button class="btn-delete" onclick="deleteRecurringExpense('${expense.id}')" title="Delete">✕</button>
                    </div>
                </div>
            </div>
        `).join('')}</div>`;
    }
    
    function setupRecurringKeywordInput() {
        const input = document.getElementById('recurringKeywordInput');
        if (!input) return;
        
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                e.preventDefault();
                addRecurringKeyword(this.value.trim());
                this.value = '';
            } else if (e.key === 'Backspace' && !this.value && newRecurringKeywords.length > 0) {
                removeRecurringKeyword(newRecurringKeywords.length - 1);
            }
        });
        
        input.addEventListener('input', debounce(previewRecurringMatches, 500));
    }
    
    function addRecurringKeyword(keyword) {
        if (!newRecurringKeywords.includes(keyword.toLowerCase())) {
            newRecurringKeywords.push(keyword);
            renderRecurringKeywords();
            previewRecurringMatches();
        }
    }
    
    function removeRecurringKeyword(index) {
        newRecurringKeywords.splice(index, 1);
        renderRecurringKeywords();
        previewRecurringMatches();
    }
    
    function renderRecurringKeywords() {
        const wrapper = document.getElementById('recurringKeywordsWrapper');
        const input = document.getElementById('recurringKeywordInput');
        
        // Remove existing tags
        wrapper.querySelectorAll('.keyword-tag, .and-connector').forEach(el => el.remove());
        
        // Add tags before input
        newRecurringKeywords.forEach((kw, i) => {
            if (i > 0) {
                const connector = document.createElement('span');
                connector.className = 'and-connector';
                connector.textContent = 'AND';
                wrapper.insertBefore(connector, input);
            }
            const tag = document.createElement('span');
            tag.className = 'keyword-tag';
            tag.innerHTML = `${escapeHtml(kw)}<button onclick="removeRecurringKeyword(${i})">×</button>`;
            wrapper.insertBefore(tag, input);
        });
    }
    
    function previewRecurringMatches() {
        const previewEl = document.getElementById('recurringPreview');
        const countEl = document.getElementById('recurringPreviewCount');
        const listEl = document.getElementById('recurringPreviewList');
        
        if (newRecurringKeywords.length === 0) {
            previewEl.style.display = 'none';
            return;
        }
        
        const matches = allTransactions.filter(t => {
            const desc = t.description.toLowerCase();
            return newRecurringKeywords.every(kw => desc.includes(kw.toLowerCase()));
        });
        
        previewEl.style.display = 'block';
        countEl.textContent = matches.length;
        listEl.innerHTML = matches.slice(0, 5).map(t => 
            `<div>${escapeHtml(t.description.substring(0, 50))}${t.description.length > 50 ? '...' : ''}</div>`
        ).join('') + (matches.length > 5 ? `<div>...and ${matches.length - 5} more</div>` : '');
    }
    
    function resetRecurringForm() {
        document.getElementById('recurringName').value = '';
        document.getElementById('recurringAmount').value = '';
        document.getElementById('recurringFrequency').value = 'monthly';
        document.getElementById('recurringCategory').value = '';
        document.getElementById('recurringKeywordInput').value = '';
        newRecurringKeywords = [];
        renderRecurringKeywords();
        document.getElementById('recurringPreview').style.display = 'none';
    }
    
    async function saveRecurringExpense() {
        const name = document.getElementById('recurringName').value.trim();
        const amount = parseFloat(document.getElementById('recurringAmount').value) || 0;
        const frequency = document.getElementById('recurringFrequency').value;
        const category = document.getElementById('recurringCategory').value.trim() || 'Other';
        
        if (!name || amount <= 0) {
            alert('Please enter a name and amount');
            return;
        }
        
        try {
            const response = await fetch('/api/recurring-expenses', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, amount, frequency, category, keywords: newRecurringKeywords })
            });
            
            const data = await response.json();
            
            if (data.success) {
                resetRecurringForm();
                await loadRecurringExpenses();
                if (typeof markAsUnsynced === 'function') markAsUnsynced();
                
                // Refresh budget data if in budget mode
                if (budgetMode) {
                    loadBudgetData();
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }
    
    async function toggleRecurringExpense(id) {
        try {
            const response = await fetch(`/api/recurring-expenses/${id}/toggle`, { method: 'POST' });
            if (response.ok) {
                await loadRecurringExpenses();
                if (budgetMode) loadBudgetData();
            }
        } catch (error) {
            console.error('Error toggling recurring expense:', error);
        }
    }
    
    async function deleteRecurringExpense(id) {
        if (!confirm('Delete this recurring expense?')) return;
        
        try {
            const response = await fetch(`/api/recurring-expenses/${id}`, { method: 'DELETE' });
            if (response.ok) {
                await loadRecurringExpenses();
                if (budgetMode) loadBudgetData();
                if (typeof markAsUnsynced === 'function') markAsUnsynced();
            }
        } catch (error) {
            console.error('Error deleting recurring expense:', error);
        }
    }
    
    // ============ END BUDGET MODE FUNCTIONS ============
    
    // Sync timeframe with Budget page
    function saveTimeframeToStorage() {
        if (lineChart && lineChart.selectedKeys && lineChart.selectedKeys.length > 0) {
            const keys = lineChart.selectedKeys;
            let startDate, endDate;
            
            if (currentPeriod === 'days') {
                startDate = keys[0];
                endDate = keys[keys.length - 1];
            } else if (currentPeriod === 'weeks') {
                startDate = keys[0];
                const lastWeekEnd = new Date(keys[keys.length - 1] + 'T12:00:00');
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                endDate = lastWeekEnd.toISOString().split('T')[0];
            } else if (currentPeriod === 'months') {
                startDate = keys[0] + '-01';
                const lastMonth = keys[keys.length - 1];
                const [year, month] = lastMonth.split('-');
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                endDate = `${lastMonth}-${lastDay}`;
            } else if (currentPeriod === 'years') {
                startDate = `${keys[0]}-01-01`;
                endDate = `${keys[keys.length - 1]}-12-31`;
            }
            
            if (startDate && endDate) {
                localStorage.setItem('spendsight_startDate', startDate);
                localStorage.setItem('spendsight_endDate', endDate);
            }
        }
    }
    let selectedPeriodIndex = null; // Track which period point is clicked on line chart
    
    // Multi-filter state management
    const activeFilters = {
        startDate: null,
        endDate: null,
        periodType: null,
        periodValue: null,
        periodDisplay: null,
        categories: [],
        necessities: [],
        recurrences: [],
        untaggedCategory: false,
        untaggedNecessity: false,
        untaggedRecurrence: false
    };
    
    // Panel filter state (temporary until applied)
    let panelFilters = {
        startDate: null,
        endDate: null,
        categories: [],
        necessities: [],
        recurrences: [],
        untaggedCategory: false,
        untaggedNecessity: false,
        untaggedRecurrence: false
    };
    
    // Colors for breakdown types
    const necessityColors = { 'Needs': '#3b82f6', 'Flexible Need': '#60a5fa', 'Wants': '#ec4899', 'Savings': '#22c55e', 'Unknown': '#64748b' };
    const recurrenceColors = { 'Subscription': '#a855f7', 'Recurring': '#14b8a6', 'One-time': '#64748b', 'Unknown': '#94a3b8' };
    
    // Helper function to update all stats displays (summary bar + analytics panel)
    function updateStatsDisplay(count, avg, median, total) {
        document.getElementById('summaryCount').textContent = count;
        document.getElementById('summaryAvg').textContent = `$${avg.toFixed(2)}`;
        document.getElementById('summaryMedian').textContent = `$${median.toFixed(2)}`;
        document.getElementById('summarySpent').textContent = `$${total.toFixed(2)}`;
        
        // Update analytics panel
        const analyticsAvg = document.getElementById('analyticsAvg');
        const analyticsMedian = document.getElementById('analyticsMedian');
        const analyticsTotal = document.getElementById('analyticsTotal');
        const analyticsCount = document.getElementById('analyticsCount');
        
        if (analyticsAvg) analyticsAvg.textContent = `$${avg.toFixed(2)}`;
        if (analyticsMedian) analyticsMedian.textContent = `$${median.toFixed(2)}`;
        if (analyticsTotal) analyticsTotal.textContent = `$${total.toFixed(2)}`;
        if (analyticsCount) analyticsCount.textContent = count;
    }
    
    const monthlyTrends = {{ monthly_trends|tojson|safe if monthly_trends else '{}' }};
    const weeklySpending = {{ weekly_spending|tojson|safe if weekly_spending else '{}' }};
    const dailySpending = {{ daily_spending|tojson|safe if daily_spending else '{}' }};
    const categories = {{ categories|tojson|safe if categories else '{}' }};
    const dayOfWeek = {{ day_of_week|tojson|safe if day_of_week else '{}' }};
    const spendingByBank = {{ spending_by_bank|tojson|safe if spending_by_bank else '{}' }};
    const classification = {{ classification|tojson|safe if classification else '{}' }};
    
    document.addEventListener('DOMContentLoaded', function() {
        initLineChart();
        initPieChart();
        initBudgetInput();
        setupRecurringKeywordInput();
        loadAllTransactions().then(() => {
            initFilterPanel();
            
            // Check if we have stored dates from Budget page and try to match them
            restoreTimeframeFromStorage();
            
            // Sync transactions to match the initial visible timeframe
            syncTransactionsToTimeframe();
        });
        
    function restoreTimeframeFromStorage() {
        const storedPeriod = localStorage.getItem('spendsight_currentPeriod') || localStorage.getItem('spendsight_dashboardPeriod');
        const storedOffset = localStorage.getItem('spendsight_periodOffset');
        
        // If we have stored period state, restore it directly
        if (storedPeriod && (storedPeriod === 'days' || storedPeriod === 'weeks' || storedPeriod === 'months' || storedPeriod === 'years')) {
            const targetBtn = document.querySelector(`.time-toggle button[data-period="${storedPeriod}"]`);
            if (targetBtn) {
                document.querySelectorAll('.time-toggle button').forEach(b => b.classList.remove('active'));
                targetBtn.classList.add('active');
                currentPeriod = storedPeriod;
                
                // Restore the period offset if available
                if (storedOffset !== null) {
                    periodOffset = parseInt(storedOffset) || 0;
                }
                
                updateLineChart();
            }
        }
    }
        
        document.querySelectorAll('.time-toggle button').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.time-toggle button').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                currentPeriod = this.dataset.period;
                periodOffset = 0; // Reset to current period when switching views
                
                // Save period state for sync with Budget page
                localStorage.setItem('spendsight_periodOffset', periodOffset.toString());
                localStorage.setItem('spendsight_currentPeriod', currentPeriod);
                
                // Sync budget timeframe with Dashboard period:
                // Days view → Weekly (W) budget
                // Weeks view → Monthly (M) budget
                if (currentPeriod === 'days') {
                    localStorage.setItem('spendsight_budgetTimeframe', 'weekly');
                    localStorage.setItem('spendsight_dashboardPeriod', 'days');
                    // Update the M/W toggle if visible
                    document.querySelectorAll('.budget-timeframe-toggle button').forEach(b => {
                        b.classList.toggle('active', b.dataset.budgetTf === 'weekly');
                    });
                    budgetTimeframe = 'weekly';
                } else if (currentPeriod === 'weeks') {
                    localStorage.setItem('spendsight_budgetTimeframe', 'monthly');
                    localStorage.setItem('spendsight_dashboardPeriod', 'weeks');
                    // Update the M/W toggle if visible
                    document.querySelectorAll('.budget-timeframe-toggle button').forEach(b => {
                        b.classList.toggle('active', b.dataset.budgetTf === 'monthly');
                    });
                    budgetTimeframe = 'monthly';
                }
                
                updateLineChart();
                // Also update pie chart if transactions is selected
                if (currentPieFilter === 'transactions') {
                    updatePieChart();
                }
                // Sync transactions to the new visible timeframe
                syncTransactionsToTimeframe();
            });
        });
        
        // Close breakdown menus when clicking outside
        document.addEventListener('click', function(e) {
            const menu = document.getElementById('breakdownMenu');
            const selector = document.getElementById('breakdownSelector');
            if (menu && selector && !selector.contains(e.target) && !menu.contains(e.target)) {
                menu.classList.remove('show');
            }
            
            const lineMenu = document.getElementById('lineBreakdownMenu');
            const lineSelector = document.getElementById('lineBreakdownSelector');
            if (lineMenu && lineSelector && !lineSelector.contains(e.target) && !lineMenu.contains(e.target)) {
                lineMenu.classList.remove('show');
            }
        });
        
        // Mark initial selected option
        updateBreakdownSelection();
    });
    
    function navigatePeriod(direction) {
        periodOffset += direction;
        updateLineChart();
        // Also update pie chart if transactions is selected
        if (currentPieFilter === 'transactions') {
            updatePieChart();
        }
        // Sync transactions to the new visible timeframe
        syncTransactionsToTimeframe();
        
        // Save period state for sync with Budget page
        localStorage.setItem('spendsight_periodOffset', periodOffset.toString());
        localStorage.setItem('spendsight_currentPeriod', currentPeriod);
        saveTimeframeToStorage();
        
        // Reload personal analysis for the new period if in budget mode
        if (budgetMode) {
            loadPersonalAnalysis();
        }
    }
    
    function toggleBreakdownMenu(event) {
        if (event) {
            event.stopPropagation();
        }
        const menu = document.getElementById('breakdownMenu');
        menu.classList.toggle('show');
    }
    
    function selectBreakdown(value, label, event) {
        if (event) {
            event.stopPropagation();
        }
        currentPieFilter = value;
        document.getElementById('breakdownLabel').textContent = label;
        document.getElementById('breakdownMenu').classList.remove('show');
        updateBreakdownSelection();
        updatePieChart();
    }
    
    function updateBreakdownSelection() {
        document.querySelectorAll('.breakdown-option').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.value === currentPieFilter);
        });
    }
    
    // Line chart breakdown functions
    function toggleLineBreakdownMenu(event) {
        if (event) event.stopPropagation();
        document.getElementById('lineBreakdownMenu').classList.toggle('show');
    }
    
    function selectLineBreakdown(value, label, event) {
        if (event) event.stopPropagation();
        currentLineBreakdown = value;
        document.getElementById('lineBreakdownLabel').textContent = label;
        document.getElementById('lineBreakdownMenu').classList.remove('show');
        updateLineBreakdownSelection();
        updateLineChart();
    }
    
    function toggleLineOption(option, event) {
        if (event) event.stopPropagation();
        if (option === 'average') {
            showAverage = !showAverage;
            document.getElementById('avgCheck').classList.toggle('active', showAverage);
        } else if (option === 'median') {
            showMedian = !showMedian;
            document.getElementById('medianCheck').classList.toggle('active', showMedian);
        }
        updateLineChart();
    }
    
    function updateLineBreakdownSelection() {
        document.querySelectorAll('.line-breakdown-option:not(.line-toggle-option)').forEach(opt => {
            opt.classList.toggle('selected', opt.dataset.value === currentLineBreakdown);
        });
    }
    
    function initLineChart() {
        const ctx = document.getElementById('spendingLineChart').getContext('2d');
        
        lineChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: []
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                plugins: {
                    legend: { 
                        display: true,
                        position: 'top',
                        align: 'end',
                        labels: { 
                            boxWidth: 12, 
                            boxHeight: 2,
                            padding: 6,
                            font: { size: 9 },
                            usePointStyle: false,
                            filter: (item) => item.text !== '_avg' && item.text !== '_median'
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(15, 23, 42, 0.95)',
                        padding: 8,
                        cornerRadius: 6,
                        titleFont: { size: 10 },
                        bodyFont: { size: 10 },
                        boxPadding: 3,
                        callbacks: {
                            label: ctx => `${ctx.dataset.label}: $${ctx.raw.toFixed(2)}`
                        },
                        // Allow tooltip to overflow chart bounds
                        position: 'nearest',
                        external: null
                    }
                },
                layout: {
                    padding: { top: 5, right: 5 }
                },
                clip: false,
                scales: {
                    y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.03)' }, ticks: { callback: v => '$' + v, font: { size: 9 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 9 }, maxRotation: 0 } }
                },
                onClick: (e, elements) => { if (elements.length > 0 && !lineChart.data.datasets[elements[0].datasetIndex].isStatLine) handleLineChartClick(elements[0].index); }
            }
        });
        updateLineBreakdownSelection();
        updateLineChart();
    }
    
    function updateLineChart() {
        let labels = [], periodData = {}, selectedKeys = [];
        const periodLabel = document.getElementById('chartPeriodLabel');
        const prevBtn = document.getElementById('periodPrev');
        const nextBtn = document.getElementById('periodNext');
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
        // Get the right data source based on period
        let dataSource;
        if (currentPeriod === 'days') {
            dataSource = dailySpending;
        } else if (currentPeriod === 'weeks') {
            dataSource = weeklySpending;
        } else if (currentPeriod === 'months') {
            dataSource = monthlyTrends;
        } else {
            dataSource = monthlyTrends; // for years, we'll aggregate
        }
        
        // Determine which keys to show and build labels
        if (currentPeriod === 'days') {
            const allDates = Object.keys(dailySpending).sort();
            const weeks = [];
            let currentWeek = [];
            allDates.forEach(date => {
                const d = new Date(date + 'T12:00:00');
                if (currentWeek.length === 0 || d.getDay() === 0) {
                    if (currentWeek.length > 0) weeks.push(currentWeek);
                    currentWeek = [date];
                } else {
                    currentWeek.push(date);
                }
            });
            if (currentWeek.length > 0) weeks.push(currentWeek);
            
            const weekIndex = Math.max(0, Math.min(weeks.length - 1 + periodOffset, weeks.length - 1));
            selectedKeys = weeks[weekIndex] || allDates.slice(-7);
            
            selectedKeys.forEach(date => {
                const d = new Date(date + 'T12:00:00');
                const label = d.toLocaleDateString('en-US', { weekday: 'short', month: 'numeric', day: 'numeric' });
                labels.push(label);
                periodData[label] = { type: 'day', value: date, display: label };
            });
            
            if (selectedKeys.length > 0) {
                const startDate = new Date(selectedKeys[0] + 'T12:00:00');
                const endDate = new Date(selectedKeys[selectedKeys.length - 1] + 'T12:00:00');
                periodLabel.textContent = `${startDate.toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})} - ${endDate.toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})}`;
            }
            prevBtn.disabled = weekIndex <= 0;
            nextBtn.disabled = weekIndex >= weeks.length - 1;
            
        } else if (currentPeriod === 'weeks') {
            const sortedWeeks = Object.keys(weeklySpending).sort();
            const totalWeeks = sortedWeeks.length;
            const weeksToShow = 4;
            let endIndex = totalWeeks + periodOffset;
            let startIndex = Math.max(0, endIndex - weeksToShow);
            endIndex = Math.min(totalWeeks, startIndex + weeksToShow);
            selectedKeys = sortedWeeks.slice(startIndex, endIndex);
            
            selectedKeys.forEach(week => {
                const startD = new Date(week + 'T12:00:00');
                const endD = new Date(startD);
                endD.setDate(endD.getDate() + 6);
                const label = `${startD.toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})}-${endD.toLocaleDateString('en-US', {month: 'numeric', day: 'numeric'})}`;
                labels.push(label);
                periodData[label] = { type: 'week', value: week, display: label };
            });
            
            if (selectedKeys.length > 0) {
                const firstWeek = new Date(selectedKeys[0] + 'T12:00:00');
                periodLabel.textContent = firstWeek.toLocaleDateString('en-US', {month: 'short', year: 'numeric'});
            }
            prevBtn.disabled = startIndex <= 0;
            nextBtn.disabled = endIndex >= totalWeeks;
            
        } else if (currentPeriod === 'months') {
            const sortedMonths = Object.keys(monthlyTrends).sort();
            const totalMonths = sortedMonths.length;
            const monthsToShow = 6;
            let endIndex = totalMonths + periodOffset;
            let startIndex = Math.max(0, endIndex - monthsToShow);
            endIndex = Math.min(totalMonths, startIndex + monthsToShow);
            selectedKeys = sortedMonths.slice(startIndex, endIndex);
            let displayYear = '';
            
            selectedKeys.forEach(month => {
                const [year, monthNum] = month.split('-');
                const monthName = monthNames[parseInt(monthNum, 10) - 1];
                labels.push(monthName);
                periodData[monthName] = { type: 'month', value: month, display: `${monthName} ${year}` };
                displayYear = year;
            });
            
            periodLabel.textContent = displayYear;
            prevBtn.disabled = startIndex <= 0;
            nextBtn.disabled = endIndex >= totalMonths;
            
        } else if (currentPeriod === 'years') {
            const sortedMonths = Object.keys(monthlyTrends).sort();
            const years = [...new Set(sortedMonths.map(m => m.split('-')[0]))].sort();
            selectedKeys = years;
            
            years.forEach(year => {
                labels.push(year);
                periodData[year] = { type: 'year', value: year, display: year };
            });
            
            if (years.length > 0) {
                periodLabel.textContent = years.length > 1 ? `${years[0]}-${years[years.length-1]}` : years[0];
            }
            prevBtn.disabled = true;
            nextBtn.disabled = true;
        }
        
        // Build datasets based on breakdown type
        let datasets = [];
        let totalData = [];
        
        if (currentLineBreakdown === 'total') {
            // Single line for total spending
            if (currentPeriod === 'years') {
                const yearlyData = {};
                Object.keys(monthlyTrends).forEach(month => {
                    const [year] = month.split('-');
                    if (!yearlyData[year]) yearlyData[year] = 0;
                    yearlyData[year] += monthlyTrends[month]?.spent || 0;
                });
                totalData = selectedKeys.map(year => yearlyData[year] || 0);
            } else {
                totalData = selectedKeys.map(key => dataSource[key]?.spent || 0);
            }
            
            datasets.push({
                label: 'Spending',
                data: totalData,
                borderColor: '#6366f1',
                backgroundColor: 'rgba(99, 102, 241, 0.1)',
                fill: true,
                tension: 0.4,
                pointRadius: 3,
                pointHoverRadius: 5,
                pointBackgroundColor: '#6366f1',
                pointBorderColor: '#fff',
                pointBorderWidth: 1.5
            });
        } else {
            // Multiple lines for breakdown
            const breakdownField = currentLineBreakdown === 'category' ? 'categories' : currentLineBreakdown;
            const colorMap = currentLineBreakdown === 'category' ? categoryColors :
                            currentLineBreakdown === 'necessity' ? necessityColors : recurrenceColors;
            
            // Collect all unique breakdown keys
            const allBreakdownKeys = new Set();
            if (currentPeriod === 'years') {
                // Aggregate by year
                selectedKeys.forEach(year => {
                    Object.keys(monthlyTrends).filter(m => m.startsWith(year)).forEach(month => {
                        const breakdown = monthlyTrends[month]?.[breakdownField] || {};
                        Object.keys(breakdown).forEach(k => allBreakdownKeys.add(k));
                    });
                });
            } else {
                selectedKeys.forEach(key => {
                    const breakdown = dataSource[key]?.[breakdownField] || {};
                    Object.keys(breakdown).forEach(k => allBreakdownKeys.add(k));
                });
            }
            
            // Create a dataset for each breakdown key (skip Unknown/Other placeholders)
            let colorIndex = 0;
            allBreakdownKeys.forEach(breakdownKey => {
                // Skip "Unknown" and "Other" placeholder tags
                if (breakdownKey === 'Unknown' || breakdownKey === 'Other') return;
                
                let data;
                if (currentPeriod === 'years') {
                    data = selectedKeys.map(year => {
                        let sum = 0;
                        Object.keys(monthlyTrends).filter(m => m.startsWith(year)).forEach(month => {
                            sum += monthlyTrends[month]?.[breakdownField]?.[breakdownKey] || 0;
                        });
                        return sum;
                    });
                } else {
                    data = selectedKeys.map(key => dataSource[key]?.[breakdownField]?.[breakdownKey] || 0);
                }
                
                const color = colorMap[breakdownKey] || colors[colorIndex % colors.length];
                datasets.push({
                    label: breakdownKey,
                    data: data,
                    borderColor: color,
                    backgroundColor: color + '20',
                    fill: false,
                    tension: 0.4,
                    pointRadius: 2,
                    pointHoverRadius: 4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 1
                });
                colorIndex++;
            });
            
            // Calculate total for avg/median
            if (currentPeriod === 'years') {
                const yearlyData = {};
                Object.keys(monthlyTrends).forEach(month => {
                    const [year] = month.split('-');
                    if (!yearlyData[year]) yearlyData[year] = 0;
                    yearlyData[year] += monthlyTrends[month]?.spent || 0;
                });
                totalData = selectedKeys.map(year => yearlyData[year] || 0);
            } else {
                totalData = selectedKeys.map(key => dataSource[key]?.spent || 0);
            }
        }
        
        // Add average line if enabled
        if (showAverage && totalData.length > 0) {
            const sum = totalData.reduce((a, b) => a + b, 0);
            const avg = sum / totalData.length;
            datasets.push({
                label: 'Average',
                data: totalData.map(() => avg),
                borderColor: '#f97316',
                borderWidth: 2,
                borderDash: [6, 4],
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0,
                isStatLine: true
            });
        }
        
        // Add median line if enabled
        if (showMedian && totalData.length > 0) {
            const sorted = [...totalData].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
            datasets.push({
                label: 'Median',
                data: totalData.map(() => median),
                borderColor: '#22c55e',
                borderWidth: 2,
                borderDash: [3, 3],
                fill: false,
                pointRadius: 0,
                pointHoverRadius: 0,
                isStatLine: true
            });
        }
        
        lineChart.data.labels = labels;
        lineChart.data.datasets = datasets;
        lineChart.periodData = periodData;
        lineChart.currentData = totalData;
        lineChart.currentLabels = labels;
        lineChart.selectedKeys = selectedKeys;  // Store for pie chart to use
        lineChart.update();
        
        // Update pie chart to reflect the visible time range
        if (pieChart) {
            updatePieChart();
        }
        
        // Refresh budget data if in budget mode (debounced to prevent rapid calls)
        if (budgetMode && !window._budgetDataLoading) {
            window._budgetDataLoading = true;
            setTimeout(() => {
                loadBudgetData().finally(() => {
                    window._budgetDataLoading = false;
                });
            }, 100);
        }
    }
    
    function handleLineChartClick(index) {
        const label = lineChart.data.labels[index];
        const periodInfo = lineChart.periodData[label];
        
        if (periodInfo) {
            selectedPeriodIndex = index;  // Track the clicked period
            // Add period filter to active filters
            activeFilters.periodType = periodInfo.type;
            activeFilters.periodValue = periodInfo.value;
            activeFilters.periodDisplay = periodInfo.display;
            // Update the timeframe badge to show the clicked period
            document.getElementById('timeframeRange').textContent = periodInfo.display;
            updateFilterChips();
            applyMultiFilters();
            updatePieChart();  // Update pie chart to show only this period's breakdown
        }
    }
    
    function initPieChart() {
        const ctx = document.getElementById('spendingPieChart').getContext('2d');
        
        pieChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: [],
                datasets: [{ data: [], backgroundColor: colors, borderWidth: 2, borderColor: '#ffffff', hoverOffset: 3 }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '45%',
                plugins: {
                    legend: { position: 'right', labels: { padding: 6, usePointStyle: true, font: { size: 9 } } },
                    tooltip: {
                        backgroundColor: 'rgba(15, 23, 42, 0.95)',
                        padding: 8,
                        cornerRadius: 6,
                        callbacks: {
                            label: ctx => {
                                const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                                return `$${ctx.raw.toFixed(2)} (${((ctx.raw / total) * 100).toFixed(1)}%)`;
                            }
                        }
                    }
                },
                onClick: (e, elements) => { if (elements.length > 0) handlePieChartClick(elements[0].index); }
            }
        });
        updatePieChart();
    }
    
    function updatePieChart() {
        let labels = [], data = [], bgColors = [];
        
        // Get visible date range from chart
        const keys = lineChart?.selectedKeys || [];
        let startDate, endDate;
        
        if (currentPeriod === 'days' && keys.length > 0) {
            startDate = keys[0];
            endDate = keys[keys.length - 1];
        } else if (currentPeriod === 'weeks' && keys.length > 0) {
            startDate = keys[0];
            const lastWeekEnd = new Date(keys[keys.length - 1] + 'T12:00:00');
            lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
            endDate = lastWeekEnd.toISOString().split('T')[0];
        } else if (currentPeriod === 'months' && keys.length > 0) {
            startDate = keys[0] + '-01';
            const lastMonth = keys[keys.length - 1];
            const [year, month] = lastMonth.split('-');
            const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
            endDate = `${lastMonth}-${lastDay}`;
        } else if (currentPeriod === 'years' && keys.length > 0) {
            startDate = `${keys[0]}-01-01`;
            endDate = `${keys[keys.length - 1]}-12-31`;
        }
        
        // Filter transactions to visible range - use FRESH data from allTransactions
        let visibleTransactions = allTransactions;
        if (startDate && endDate) {
            visibleTransactions = allTransactions.filter(t => {
                const txDate = t.transaction_date;
                return txDate >= startDate && txDate <= endDate;
            });
        }
        
        // If a specific period is selected, narrow down further
        if (selectedPeriodIndex !== null && keys.length > 0) {
            const selectedKey = keys[selectedPeriodIndex];
            if (selectedKey) {
                if (currentPeriod === 'days') {
                    visibleTransactions = visibleTransactions.filter(t => t.transaction_date === selectedKey);
                } else if (currentPeriod === 'weeks') {
                    const weekStart = new Date(selectedKey + 'T12:00:00');
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekEnd.getDate() + 6);
                    const start = selectedKey;
                    const end = weekEnd.toISOString().split('T')[0];
                    visibleTransactions = visibleTransactions.filter(t => t.transaction_date >= start && t.transaction_date <= end);
                } else if (currentPeriod === 'months') {
                    visibleTransactions = visibleTransactions.filter(t => t.transaction_date.startsWith(selectedKey));
                } else if (currentPeriod === 'years') {
                    visibleTransactions = visibleTransactions.filter(t => t.transaction_date.startsWith(selectedKey));
                }
            }
        }
        
        // Only use expenses for pie chart
        const expenses = visibleTransactions.filter(t => t.amount < 0 || t.type === 'expense');
        
        const localNecessityColors = { 'Needs': '#3b82f6', 'Flexible Need': '#60a5fa', 'Wants': '#ec4899', 'Savings': '#22c55e', 'Unknown': '#64748b' };
        const localRecurrenceColors = { 'Subscription': '#a855f7', 'Recurring': '#14b8a6', 'One-time': '#64748b', 'Unknown': '#94a3b8' };
        
        if (currentPieFilter === 'category') {
            // Calculate categories from FRESH transaction data
            const catTotals = {};
            expenses.forEach(t => {
                const cat = t.category || 'Uncategorized';
                // Skip "Unknown" and "Other" placeholder categories
                if (cat !== 'Unknown' && cat !== 'Other') {
                    catTotals[cat] = (catTotals[cat] || 0) + Math.abs(t.amount);
                }
            });
            const sortedCats = Object.entries(catTotals).sort((a, b) => b[1] - a[1]);
            sortedCats.forEach(([cat, total], i) => {
                labels.push(cat);
                data.push(total);
                bgColors.push(categoryColors[cat] || colors[i % colors.length]);
            });
            pieChart.filterType = 'category';
        } else if (currentPieFilter === 'necessity') {
            // Calculate necessity from FRESH transaction data
            const necTotals = {};
            expenses.forEach(t => {
                const nec = t.necessity || 'Unknown';
                // Skip "Unknown" placeholder
                if (nec !== 'Unknown') {
                    necTotals[nec] = (necTotals[nec] || 0) + Math.abs(t.amount);
                }
            });
            const sortedNec = Object.entries(necTotals).sort((a, b) => b[1] - a[1]);
            sortedNec.forEach(([type, total], i) => {
                labels.push(type);
                data.push(total);
                bgColors.push(localNecessityColors[type] || colors[i % colors.length]);
            });
            pieChart.filterType = 'necessity';
        } else if (currentPieFilter === 'recurrence') {
            // Calculate recurrence from FRESH transaction data
            const recTotals = {};
            expenses.forEach(t => {
                const rec = t.recurrence || 'Unknown';
                // Skip "Unknown" placeholder
                if (rec !== 'Unknown') {
                    recTotals[rec] = (recTotals[rec] || 0) + Math.abs(t.amount);
                }
            });
            const sortedRec = Object.entries(recTotals).sort((a, b) => b[1] - a[1]);
            sortedRec.forEach(([type, total], i) => {
                labels.push(type);
                data.push(total);
                bgColors.push(localRecurrenceColors[type] || colors[i % colors.length]);
            });
            pieChart.filterType = 'recurrence';
        } else if (currentPieFilter === 'transactions') {
            // Show spending breakdown by transaction description (title)
            const keys = lineChart?.selectedKeys || [];
            let startDate, endDate;
            
            // Determine the date range based on current period
            if (currentPeriod === 'days' && keys.length > 0) {
                startDate = keys[0];
                endDate = keys[keys.length - 1];
            } else if (currentPeriod === 'weeks' && keys.length > 0) {
                startDate = keys[0];
                const lastWeekStart = new Date(keys[keys.length - 1] + 'T12:00:00');
                const lastWeekEnd = new Date(lastWeekStart);
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                endDate = lastWeekEnd.toISOString().split('T')[0];
            } else if (currentPeriod === 'months' && keys.length > 0) {
                startDate = keys[0] + '-01';
                const lastMonth = keys[keys.length - 1];
                const [year, month] = lastMonth.split('-');
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                endDate = `${lastMonth}-${lastDay}`;
            } else if (currentPeriod === 'years' && keys.length > 0) {
                startDate = `${keys[0]}-01-01`;
                endDate = `${keys[keys.length - 1]}-12-31`;
            }
            
            // Filter transactions to the visible timeframe and aggregate by description
            const transactionsByDesc = {};
            if (startDate && endDate) {
                allTransactions.forEach(t => {
                    if (t.transaction_date >= startDate && t.transaction_date <= endDate) {
                        const amount = Math.abs(t.amount);
                        if (amount > 0 && (t.amount < 0 || t.type === 'expense')) {
                            const desc = t.description || 'Unknown';
                            transactionsByDesc[desc] = (transactionsByDesc[desc] || 0) + amount;
                        }
                    }
                });
            }
            
            // Sort by amount and take top entries
            const sortedTx = Object.entries(transactionsByDesc)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10); // Show top 10 transactions
            
            sortedTx.forEach(([desc, total], i) => {
                // Truncate long descriptions
                const displayDesc = desc.length > 25 ? desc.substring(0, 22) + '...' : desc;
                labels.push(displayDesc);
                data.push(total);
                bgColors.push(colors[i % colors.length]);
            });
            
            pieChart.filterType = 'transaction';
            pieChart.transactionData = Object.fromEntries(sortedTx.map(([desc, total], i) => {
                const displayDesc = desc.length > 25 ? desc.substring(0, 22) + '...' : desc;
                return [displayDesc, desc];  // Map truncated to full description
            }));
        } else if (currentPieFilter === 'bank') {
            // Aggregate bank from visible period
            const aggregatedBank = aggregateBreakdown('bank');
            const sortedBank = Object.entries(aggregatedBank)
                .sort((a, b) => b[1] - a[1]);
            sortedBank.forEach(([bank, total]) => {
                labels.push(bank);
                data.push(total);
                bgColors.push(bank.toLowerCase() === 'chase' ? '#0066b2' : '#ff6000');
            });
            pieChart.filterType = 'bank';
        }
        
        pieChart.data.labels = labels;
        pieChart.data.datasets[0].data = data;
        pieChart.data.datasets[0].backgroundColor = bgColors;
        pieChart.update();
    }
    
    function handlePieChartClick(index) {
        const label = pieChart.data.labels[index];
        let filterType = pieChart.filterType;
        let filterValue = label;
        
        // For transaction filter, filter by the transaction description
        if (filterType === 'transaction' && pieChart.transactionData) {
            const fullDesc = pieChart.transactionData[label] || label;
            // Filter transactions list to show only this transaction description
            const keys = lineChart?.selectedKeys || [];
            let startDate, endDate;
            
            if (currentPeriod === 'days' && keys.length > 0) {
                startDate = keys[0];
                endDate = keys[keys.length - 1];
            } else if (currentPeriod === 'weeks' && keys.length > 0) {
                startDate = keys[0];
                const lastWeekStart = new Date(keys[keys.length - 1] + 'T12:00:00');
                const lastWeekEnd = new Date(lastWeekStart);
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                endDate = lastWeekEnd.toISOString().split('T')[0];
            } else if (currentPeriod === 'months' && keys.length > 0) {
                startDate = keys[0] + '-01';
                const lastMonth = keys[keys.length - 1];
                const [year, month] = lastMonth.split('-');
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                endDate = `${lastMonth}-${lastDay}`;
            } else if (currentPeriod === 'years' && keys.length > 0) {
                startDate = `${keys[0]}-01-01`;
                endDate = `${keys[keys.length - 1]}-12-31`;
            }
            
            // Filter to matching transactions in the visible timeframe
            const filtered = allTransactions.filter(t => {
                if (startDate && endDate) {
                    if (t.transaction_date < startDate || t.transaction_date > endDate) return false;
                }
                return t.description === fullDesc;
            });
            
            // Update display
            document.getElementById('transactionsTitle').textContent = `"${label}"`;
            document.getElementById('timeframeRange').textContent = label;
            
            const amounts = filtered.filter(t => t.amount < 0 || t.type === 'expense').map(t => Math.abs(t.amount));
            const total = amounts.reduce((a, b) => a + b, 0);
            const avg = amounts.length > 0 ? total / amounts.length : 0;
            const sortedAmounts = [...amounts].sort((a, b) => a - b);
            const median = sortedAmounts.length > 0 ? 
                (sortedAmounts.length % 2 === 0 
                    ? (sortedAmounts[sortedAmounts.length/2 - 1] + sortedAmounts[sortedAmounts.length/2]) / 2 
                    : sortedAmounts[Math.floor(sortedAmounts.length/2)]) 
                : 0;
            
            updateStatsDisplay(filtered.length, avg, median, total);
            
            renderTransactions(filtered);
            return;
        }
        
        // Set the date range from the visible timeframe to ensure date filtering is applied
        const keys = lineChart?.selectedKeys || [];
        if (keys.length > 0) {
            // Always sync date range to the current visible timeframe
            if (currentPeriod === 'days') {
                activeFilters.startDate = keys[0];
                activeFilters.endDate = keys[keys.length - 1];
            } else if (currentPeriod === 'weeks') {
                activeFilters.startDate = keys[0];
                const lastWeekStart = new Date(keys[keys.length - 1] + 'T12:00:00');
                const lastWeekEnd = new Date(lastWeekStart);
                lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                activeFilters.endDate = lastWeekEnd.toISOString().split('T')[0];
            } else if (currentPeriod === 'months') {
                activeFilters.startDate = keys[0] + '-01';
                const lastMonth = keys[keys.length - 1];
                const [year, month] = lastMonth.split('-');
                const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
                activeFilters.endDate = `${lastMonth}-${lastDay}`;
            } else if (currentPeriod === 'years') {
                activeFilters.startDate = `${keys[0]}-01-01`;
                activeFilters.endDate = `${keys[keys.length - 1]}-12-31`;
            }
        }
        
        // Replace filter (not add) when clicking pie chart - single selection only
        // Clear all tag filters first, then set just the clicked one
        activeFilters.categories = [];
        activeFilters.necessities = [];
        activeFilters.recurrences = [];
        
        if (filterType === 'category') {
            activeFilters.categories = [filterValue];
        } else if (filterType === 'necessity') {
            activeFilters.necessities = [filterValue];
        } else if (filterType === 'recurrence') {
            activeFilters.recurrences = [filterValue];
        }
        
        updateFilterChips();
        // Skip pie chart update when filtering from pie chart click - pie chart should show full breakdown
        window._skipPieChartUpdate = true;
        applyMultiFilters();
    }
    
    function showActiveFilter(label) {
        document.getElementById('activeFilter').classList.add('visible');
        document.getElementById('filterLabel').textContent = label;
    }
    
    async function loadAllTransactions() {
        try {
            const response = await fetch('/api/transactions');
            allTransactions = await response.json();
            
            // Also update known categories from fresh data
            allTransactions.forEach(t => {
                if (t.category) knownCategories.add(t.category);
                if (t.necessity) knownNecessities.add(t.necessity);
                if (t.recurrence) knownRecurrences.add(t.recurrence);
            });
            
            renderTransactions(allTransactions);
            
            // Refresh pie chart to reflect any category/tag changes
            if (pieChart) {
                updatePieChart();
            }
        } catch (error) {
            document.getElementById('transactionsList').innerHTML = `<div class="no-transactions"><p>Error loading</p></div>`;
        }
    }
    
    async function loadFilteredTransactions(periodType, periodValue) {
        document.getElementById('transactionsTitle').textContent = 'Filtered';
        
        try {
            let url = `/api/transactions/filter?period_type=${encodeURIComponent(periodType)}&period_value=${encodeURIComponent(periodValue)}`;
            if (periodType === 'category') {
                url = `/api/transactions/filter?category=${encodeURIComponent(periodValue)}`;
            }
            
            const response = await fetch(url);
            const result = await response.json();
            
            // Calculate avg and median for filtered transactions
            const filteredAmounts = result.transactions
                .filter(t => t.amount < 0 || t.type === 'expense')
                .map(t => Math.abs(t.amount));
            const avg = filteredAmounts.length > 0 ? filteredAmounts.reduce((a, b) => a + b, 0) / filteredAmounts.length : 0;
            const sortedAmounts = [...filteredAmounts].sort((a, b) => a - b);
            const median = sortedAmounts.length > 0 ? 
                (sortedAmounts.length % 2 === 0 
                    ? (sortedAmounts[sortedAmounts.length/2 - 1] + sortedAmounts[sortedAmounts.length/2]) / 2 
                    : sortedAmounts[Math.floor(sortedAmounts.length/2)]) 
                : 0;
            
            updateStatsDisplay(result.summary.count, avg, median, result.summary.total_spent);
            
            renderTransactions(result.transactions);
        } catch (error) {
            console.error('Error:', error);
        }
    }
    
    function applySorting() {
        currentSort = document.getElementById('sortOrder').value;
        renderTransactions(displayedTransactions);
    }
    
    function sortTransactions(transactions) {
        const sorted = [...transactions];
        
        sorted.sort((a, b) => {
            if (currentSort === 'date-desc') {
                return new Date(b.transaction_date) - new Date(a.transaction_date);
            } else if (currentSort === 'date-asc') {
                return new Date(a.transaction_date) - new Date(b.transaction_date);
            } else if (currentSort === 'amount-desc') {
                return Math.abs(b.amount) - Math.abs(a.amount);
            } else if (currentSort === 'amount-asc') {
                return Math.abs(a.amount) - Math.abs(b.amount);
            }
            return 0;
        });
        
        return sorted;
    }
    
    function renderTransactions(transactions) {
        const container = document.getElementById('transactionsList');
        displayedTransactions = transactions;
        
        if (!transactions || transactions.length === 0) {
            container.innerHTML = `<div class="no-transactions"><p>No transactions found</p></div>`;
            return;
        }
        
        transactions = sortTransactions(transactions);
        
        container.innerHTML = transactions.map((t, idx) => {
            const isExpense = t.amount < 0 || t.type === 'expense';
            const amount = Math.abs(t.amount);
            const necessity = t.necessity || 'Unknown';
            const recurrence = t.recurrence || 'One-time';
            
            // Store transaction data for click handler
            const txData = JSON.stringify(t).replace(/"/g, '&quot;');
            
            // Check if this is an Income category transaction
            const isIncomeCategory = (t.category || '').toLowerCase() === 'income';
            
            // Build badges HTML - all clickable
            let badgesHtml = '';
            
            if (isIncomeCategory) {
                // For Income category: only show recurrence badge (if not Unknown)
                // Income doesn't have Needs/Wants/Savings - it IS the income
                if (recurrence && recurrence !== 'Unknown') {
                    const recurrenceClass = recurrence.toLowerCase().replace('-', '');
                    badgesHtml += `<span class="mini-badge ${recurrenceClass}" 
                        onclick="openTagEdit(this, ${txData}, 'recurrence', '${escapeHtml(recurrence)}')"
                        title="Click to edit">${recurrence}</span>`;
                }
            } else {
                // For expenses: show necessity and recurrence badges
                // Show necessity badge if not Unknown
                if (necessity && necessity !== 'Unknown') {
                    const necessityClass = necessity.toLowerCase().replace(' ', '');
                    badgesHtml += `<span class="mini-badge ${necessityClass}" 
                        onclick="openTagEdit(this, ${txData}, 'necessity', '${escapeHtml(necessity)}')"
                        title="Click to edit">${necessity}</span>`;
                }
                // Show recurrence badge if not Unknown
                if (recurrence && recurrence !== 'Unknown') {
                    const recurrenceClass = recurrence.toLowerCase().replace('-', '');
                    badgesHtml += `<span class="mini-badge ${recurrenceClass}" 
                        onclick="openTagEdit(this, ${txData}, 'recurrence', '${escapeHtml(recurrence)}')"
                        title="Click to edit">${recurrence}</span>`;
                }
            }
            
            // Determine what to show in meta: note if exists, otherwise bank
            const metaSecondary = t.note ? 
                `<span class="transaction-note">${escapeHtml(t.note)}</span>` : 
                `<span>${t.bank || ''}</span>`;
            
            return `
                <div class="transaction-item">
                    <div class="transaction-info">
                        <div class="transaction-description">${escapeHtml(t.description)}</div>
                        <div class="transaction-meta">
                            <span>${formatDate(t.transaction_date)}</span>
                            <span>•</span>
                            ${metaSecondary}
                        </div>
                    </div>
                    <div class="transaction-badges">
                        <span class="add-tag-btn" onclick="openAddTagMenu(this, ${txData})" title="Add tag or note">+</span>
                            <span class="transaction-category ${(!t.category || t.category === 'Other') ? 'uncategorized' : ''}" 
                              onclick="openTagEdit(this, ${txData}, 'category', '${escapeHtml(t.category || 'Uncategorized')}')" 
                                  title="Click to edit category">
                                ${escapeHtml(t.category && t.category !== 'Other' ? t.category : 'Uncategorized')}
                            </span>
                        ${badgesHtml}
                    </div>
                    <span class="transaction-amount ${isExpense ? 'expense' : 'income'}">${isExpense ? '-' : '+'}$${amount.toFixed(2)}</span>
                </div>`;
        }).join('');
    }
    
    function clearAllFilters() {
        // Reset all active filters
        activeFilters.startDate = null;
        activeFilters.endDate = null;
        activeFilters.periodType = null;
        activeFilters.periodValue = null;
        activeFilters.periodDisplay = null;
        activeFilters.categories = [];
        activeFilters.necessities = [];
        activeFilters.recurrences = [];
        activeFilters.untaggedCategory = false;
        activeFilters.untaggedNecessity = false;
        activeFilters.untaggedRecurrence = false;
        
        // Update UI
        updateFilterChips();
        document.getElementById('activeFilter').classList.remove('visible');
        
        // Reset selected period and update pie chart to show full visible range
        selectedPeriodIndex = null;
        if (pieChart) {
            updatePieChart();
        }
        
        // Try to sync transactions to visible timeframe, with fallback to all transactions
        if (lineChart && lineChart.selectedKeys && lineChart.selectedKeys.length > 0) {
            syncTransactionsToTimeframe();
        } else {
            // Fallback: reset to all transactions if no chart timeframe available
            document.getElementById('transactionsTitle').textContent = 'All Transactions';
            document.getElementById('timeframeRange').textContent = 'All Time';
            updateStatsDisplay(
                {{ statistics.count }},
                {{ statistics.mean if statistics.mean else 0 }},
                {{ statistics.median if statistics.median else 0 }},
                {{ statistics.total }}
            );
            renderTransactions(allTransactions);
        }
    }
    
    // =========================================================================
    // TIMEFRAME SYNC - Filter transactions to match visible chart range
    // =========================================================================
    
    function syncTransactionsToTimeframe() {
        if (!lineChart || !lineChart.selectedKeys || lineChart.selectedKeys.length === 0) {
            return;
        }
        
        const keys = lineChart.selectedKeys;
        let startDate, endDate, displayLabel;
        
        if (currentPeriod === 'days') {
            // Keys are dates like '2024-01-15'
            startDate = keys[0];
            endDate = keys[keys.length - 1];
            const sD = new Date(startDate + 'T12:00:00');
            const eD = new Date(endDate + 'T12:00:00');
            displayLabel = `${sD.toLocaleDateString('en-US', {month: 'short', day: 'numeric'})} – ${eD.toLocaleDateString('en-US', {month: 'short', day: 'numeric'})}`;
        } else if (currentPeriod === 'weeks') {
            // Keys are week start dates like '2024-01-08'
            startDate = keys[0];
            const lastWeekStart = new Date(keys[keys.length - 1] + 'T12:00:00');
            const lastWeekEnd = new Date(lastWeekStart);
            lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
            endDate = lastWeekEnd.toISOString().split('T')[0];
            const sD = new Date(startDate + 'T12:00:00');
            displayLabel = `${sD.toLocaleDateString('en-US', {month: 'short', day: 'numeric'})} – ${lastWeekEnd.toLocaleDateString('en-US', {month: 'short', day: 'numeric'})}`;
        } else if (currentPeriod === 'months') {
            // Keys are months like '2024-01'
            const firstMonth = keys[0];
            const lastMonth = keys[keys.length - 1];
            startDate = firstMonth + '-01';
            // Calculate last day of the last month
            const [year, month] = lastMonth.split('-');
            const lastDay = new Date(parseInt(year), parseInt(month), 0).getDate();
            endDate = `${lastMonth}-${lastDay}`;
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const startMonthName = monthNames[parseInt(firstMonth.split('-')[1]) - 1];
            const endMonthName = monthNames[parseInt(lastMonth.split('-')[1]) - 1];
            displayLabel = `${startMonthName} – ${endMonthName} ${year}`;
        } else if (currentPeriod === 'years') {
            // Keys are years like '2024'
            const firstYear = keys[0];
            const lastYear = keys[keys.length - 1];
            startDate = `${firstYear}-01-01`;
            endDate = `${lastYear}-12-31`;
            displayLabel = firstYear === lastYear ? firstYear : `${firstYear} – ${lastYear}`;
        }
        
        // Update the timeframe badge
        document.getElementById('timeframeRange').textContent = displayLabel;
        
        // Filter transactions to match the visible timeframe
        const filteredTransactions = allTransactions.filter(t => {
            const txDate = t.transaction_date;
            return txDate >= startDate && txDate <= endDate;
        });
        
        // Update the transactions title and summary
        document.getElementById('transactionsTitle').textContent = displayLabel;
        
        // Calculate stats for filtered transactions
        const expenses = filteredTransactions.filter(t => t.amount < 0 || t.type === 'expense');
        const amounts = expenses.map(t => Math.abs(t.amount));
        const total = amounts.reduce((a, b) => a + b, 0);
        const avg = amounts.length > 0 ? total / amounts.length : 0;
        const sortedAmounts = [...amounts].sort((a, b) => a - b);
        const median = sortedAmounts.length > 0 ? 
            (sortedAmounts.length % 2 === 0 
                ? (sortedAmounts[sortedAmounts.length/2 - 1] + sortedAmounts[sortedAmounts.length/2]) / 2 
                : sortedAmounts[Math.floor(sortedAmounts.length/2)]) 
            : 0;
        
        updateStatsDisplay(filteredTransactions.length, avg, median, total);
        
        // Clear the selected period index since we're syncing to full visible range
        selectedPeriodIndex = null;
        
        // Clear any active period filters from chips
        activeFilters.periodType = null;
        activeFilters.periodValue = null;
        activeFilters.periodDisplay = null;
        updateFilterChips();
        
        // Render the filtered transactions
        renderTransactions(filteredTransactions);
        
        // Save to localStorage for sync with Budget page
        localStorage.setItem('spendsight_startDate', startDate);
        localStorage.setItem('spendsight_endDate', endDate);
    }
    
    // =========================================================================
    // MULTI-FILTER SYSTEM
    // =========================================================================
    
    function initFilterPanel() {
        // Populate category options from server-rendered data
        const categoryContainer = document.getElementById('categoryTagOptions');
        const allCategories = Object.keys(categories).sort();
        
        if (categoryContainer && allCategories.length > 0) {
            categoryContainer.innerHTML = allCategories.map(cat => `
                <label class="tag-option">
                    <input type="checkbox" value="${escapeHtml(cat)}" onchange="toggleTagFilter('category', '${escapeHtml(cat)}')">
                    <span>${escapeHtml(cat)}</span>
                </label>
            `).join('');
        }
        
        // Set min/max date values based on loaded transactions
        if (allTransactions && allTransactions.length > 0) {
            const dates = allTransactions.map(t => new Date(t.transaction_date + 'T12:00:00'));
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            
            const startInput = document.getElementById('filterStartDate');
            const endInput = document.getElementById('filterEndDate');
            
            if (startInput && endInput) {
                startInput.min = minDate.toISOString().split('T')[0];
                startInput.max = maxDate.toISOString().split('T')[0];
                endInput.min = minDate.toISOString().split('T')[0];
                endInput.max = maxDate.toISOString().split('T')[0];
            }
        }
    }
    
    function openFilterPanel() {
        // Sync panel state with active filters
        panelFilters.startDate = activeFilters.startDate;
        panelFilters.endDate = activeFilters.endDate;
        panelFilters.categories = [...activeFilters.categories];
        panelFilters.necessities = [...activeFilters.necessities];
        panelFilters.recurrences = [...activeFilters.recurrences];
        panelFilters.untaggedCategory = activeFilters.untaggedCategory;
        panelFilters.untaggedNecessity = activeFilters.untaggedNecessity;
        panelFilters.untaggedRecurrence = activeFilters.untaggedRecurrence;
        
        // Update checkboxes
        syncPanelCheckboxes();
        
        // Update date inputs
        if (activeFilters.startDate) {
            document.getElementById('filterStartDate').value = activeFilters.startDate;
        }
        if (activeFilters.endDate) {
            document.getElementById('filterEndDate').value = activeFilters.endDate;
        }
        
        document.getElementById('filterPanelOverlay').classList.add('show');
        document.getElementById('filterPanel').classList.add('show');
    }
    
    function closeFilterPanel() {
        document.getElementById('filterPanelOverlay').classList.remove('show');
        document.getElementById('filterPanel').classList.remove('show');
    }
    
    function syncPanelCheckboxes() {
        // Reset all tag checkboxes
        document.querySelectorAll('.tag-options input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            cb.closest('.tag-option').classList.remove('selected');
        });
        
        // Reset untagged checkboxes
        document.querySelectorAll('.untagged-option input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            cb.closest('.untagged-option').classList.remove('selected');
        });
        
        // Check active categories
        panelFilters.categories.forEach(cat => {
            const cb = document.querySelector(`#categoryTagOptions input[value="${cat}"]`);
            if (cb) {
                cb.checked = true;
                cb.closest('.tag-option').classList.add('selected');
            }
        });
        
        // Check active necessities
        panelFilters.necessities.forEach(nec => {
            const cb = document.querySelector(`#necessityTagOptions input[value="${nec}"]`);
            if (cb) {
                cb.checked = true;
                cb.closest('.tag-option').classList.add('selected');
            }
        });
        
        // Check active recurrences
        panelFilters.recurrences.forEach(rec => {
            const cb = document.querySelector(`#recurrenceTagOptions input[value="${rec}"]`);
            if (cb) {
                cb.checked = true;
                cb.closest('.tag-option').classList.add('selected');
            }
        });
        
        // Check active untagged filters
        if (panelFilters.untaggedCategory) {
            const cb = document.getElementById('untaggedCategory');
            if (cb) {
                cb.checked = true;
                cb.closest('.untagged-option').classList.add('selected');
            }
        }
        if (panelFilters.untaggedNecessity) {
            const cb = document.getElementById('untaggedNecessity');
            if (cb) {
                cb.checked = true;
                cb.closest('.untagged-option').classList.add('selected');
            }
        }
        if (panelFilters.untaggedRecurrence) {
            const cb = document.getElementById('untaggedRecurrence');
            if (cb) {
                cb.checked = true;
                cb.closest('.untagged-option').classList.add('selected');
            }
        }
    }
    
    function toggleTagFilter(type, value) {
        const arr = type === 'category' ? panelFilters.categories : 
                    type === 'necessity' ? panelFilters.necessities : 
                    panelFilters.recurrences;
        
        const idx = arr.indexOf(value);
        if (idx === -1) {
            arr.push(value);
        } else {
            arr.splice(idx, 1);
        }
        
        // Update visual state
        const checkbox = event.target;
        checkbox.closest('.tag-option').classList.toggle('selected', checkbox.checked);
    }
    
    function toggleUntaggedFilter(type) {
        const checkbox = event.target;
        const isChecked = checkbox.checked;
        
        if (type === 'category') {
            panelFilters.untaggedCategory = isChecked;
        } else if (type === 'necessity') {
            panelFilters.untaggedNecessity = isChecked;
        } else if (type === 'recurrence') {
            panelFilters.untaggedRecurrence = isChecked;
        }
        
        // Update visual state
        checkbox.closest('.untagged-option').classList.toggle('selected', isChecked);
    }
    
    function resetPanelFilters() {
        panelFilters.startDate = null;
        panelFilters.endDate = null;
        panelFilters.categories = [];
        panelFilters.necessities = [];
        panelFilters.recurrences = [];
        panelFilters.untaggedCategory = false;
        panelFilters.untaggedNecessity = false;
        panelFilters.untaggedRecurrence = false;
        
        // Reset date inputs
        document.getElementById('filterStartDate').value = '';
        document.getElementById('filterEndDate').value = '';
        
        // Reset all tag checkboxes
        document.querySelectorAll('.tag-options input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            cb.closest('.tag-option').classList.remove('selected');
        });
        
        // Reset untagged checkboxes
        document.querySelectorAll('.untagged-option input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            cb.closest('.untagged-option').classList.remove('selected');
        });
    }
    
    function applyPanelFilters() {
        // Get date values
        const startDate = document.getElementById('filterStartDate').value;
        const endDate = document.getElementById('filterEndDate').value;
        
        // Clear period filter if date range is specified
        if (startDate || endDate) {
            activeFilters.periodType = null;
            activeFilters.periodValue = null;
            activeFilters.periodDisplay = null;
        }
        
        // Apply date filters
        activeFilters.startDate = startDate || null;
        activeFilters.endDate = endDate || null;
        
        // Apply tag filters
        activeFilters.categories = [...panelFilters.categories];
        activeFilters.necessities = [...panelFilters.necessities];
        activeFilters.recurrences = [...panelFilters.recurrences];
        
        // Apply untagged filters
        activeFilters.untaggedCategory = panelFilters.untaggedCategory;
        activeFilters.untaggedNecessity = panelFilters.untaggedNecessity;
        activeFilters.untaggedRecurrence = panelFilters.untaggedRecurrence;
        
        closeFilterPanel();
        updateFilterChips();
        applyMultiFilters();
    }
    
    function updateFilterChips() {
        const container = document.getElementById('filterChips');
        const chips = [];
        
        // Date range chip
        if (activeFilters.startDate || activeFilters.endDate) {
            const dateLabel = activeFilters.startDate && activeFilters.endDate 
                ? `${formatDateShort(activeFilters.startDate)} - ${formatDateShort(activeFilters.endDate)}`
                : activeFilters.startDate 
                    ? `From ${formatDateShort(activeFilters.startDate)}`
                    : `Until ${formatDateShort(activeFilters.endDate)}`;
            chips.push(createChipHTML('date', dateLabel, 'date'));
        }
        
        // Period chip (from line chart click)
        if (activeFilters.periodDisplay) {
            chips.push(createChipHTML('period', activeFilters.periodDisplay, 'period'));
        }
        
        // Category chips
        activeFilters.categories.forEach(cat => {
            chips.push(createChipHTML('cat', cat, `category:${cat}`));
        });
        
        // Necessity chips
        activeFilters.necessities.forEach(nec => {
            chips.push(createChipHTML('need', nec, `necessity:${nec}`));
        });
        
        // Recurrence chips
        activeFilters.recurrences.forEach(rec => {
            chips.push(createChipHTML('rec', rec, `recurrence:${rec}`));
        });
        
        // Untagged chips
        if (activeFilters.untaggedCategory) {
            chips.push(createChipHTML('', 'No Category', 'untagged:category'));
        }
        if (activeFilters.untaggedNecessity) {
            chips.push(createChipHTML('', 'No Necessity', 'untagged:necessity'));
        }
        if (activeFilters.untaggedRecurrence) {
            chips.push(createChipHTML('', 'No Recurrence', 'untagged:recurrence'));
        }
        
        container.innerHTML = chips.join('');
        
        // Show/hide clear all button
        const hasFilters = chips.length > 0;
        document.getElementById('clearAllBtn').style.display = hasFilters ? 'block' : 'none';
    }
    
    function createChipHTML(type, value, removeKey) {
        return `
            <span class="filter-chip">
                <span class="chip-type">${type}</span>
                <span class="chip-value">${escapeHtml(value)}</span>
                <button class="chip-remove" onclick="removeFilter('${removeKey}')">✕</button>
            </span>
        `;
    }
    
    function removeFilter(key) {
        if (key === 'date') {
            activeFilters.startDate = null;
            activeFilters.endDate = null;
        } else if (key === 'period') {
            activeFilters.periodType = null;
            activeFilters.periodValue = null;
            activeFilters.periodDisplay = null;
            selectedPeriodIndex = null;
        } else if (key.startsWith('category:')) {
            const cat = key.replace('category:', '');
            activeFilters.categories = activeFilters.categories.filter(c => c !== cat);
        } else if (key.startsWith('necessity:')) {
            const nec = key.replace('necessity:', '');
            activeFilters.necessities = activeFilters.necessities.filter(n => n !== nec);
        } else if (key.startsWith('recurrence:')) {
            const rec = key.replace('recurrence:', '');
            activeFilters.recurrences = activeFilters.recurrences.filter(r => r !== rec);
        } else if (key === 'untagged:category') {
            activeFilters.untaggedCategory = false;
        } else if (key === 'untagged:necessity') {
            activeFilters.untaggedNecessity = false;
        } else if (key === 'untagged:recurrence') {
            activeFilters.untaggedRecurrence = false;
        }
        
        updateFilterChips();
        
        // Check if any filters remain
        const hasFilters = activeFilters.startDate || activeFilters.endDate || 
                          activeFilters.periodType || 
                          activeFilters.categories.length || 
                          activeFilters.necessities.length || 
                          activeFilters.recurrences.length ||
                          activeFilters.untaggedCategory ||
                          activeFilters.untaggedNecessity ||
                          activeFilters.untaggedRecurrence;
        
        if (hasFilters) {
            applyMultiFilters();
        } else {
            // Reset to all transactions
            document.getElementById('transactionsTitle').textContent = 'All Transactions';
            updateStatsDisplay(
                {{ statistics.count }},
                {{ statistics.mean if statistics.mean else 0 }},
                {{ statistics.median if statistics.median else 0 }},
                {{ statistics.total }}
            );
            renderTransactions(allTransactions);
            
            if (pieChart) {
                updatePieChart();
            }
        }
    }
    
    async function applyMultiFilters() {
        document.getElementById('transactionsTitle').textContent = 'Filtered';
        
        try {
            // Build query string with all active filters
            const params = new URLSearchParams();
            
            if (activeFilters.startDate) {
                params.append('start_date', activeFilters.startDate);
            }
            if (activeFilters.endDate) {
                params.append('end_date', activeFilters.endDate);
            }
            if (activeFilters.periodType && activeFilters.periodValue) {
                params.append('period_type', activeFilters.periodType);
                params.append('period_value', activeFilters.periodValue);
            }
            
            // Multiple categories
            activeFilters.categories.forEach(cat => {
                params.append('categories', cat);
            });
            
            // Multiple necessities
            activeFilters.necessities.forEach(nec => {
                params.append('necessities', nec);
            });
            
            // Multiple recurrences
            activeFilters.recurrences.forEach(rec => {
                params.append('recurrences', rec);
            });
            
            // Untagged filters
            if (activeFilters.untaggedCategory) {
                params.append('untagged_category', 'true');
            }
            if (activeFilters.untaggedNecessity) {
                params.append('untagged_necessity', 'true');
            }
            if (activeFilters.untaggedRecurrence) {
                params.append('untagged_recurrence', 'true');
            }
            
            const response = await fetch(`/api/transactions/filter?${params.toString()}`);
            const result = await response.json();
            
            // Calculate avg and median for filtered transactions
            const filteredAmounts = result.transactions
                .filter(t => t.amount < 0 || t.type === 'expense')
                .map(t => Math.abs(t.amount));
            const avg = filteredAmounts.length > 0 ? filteredAmounts.reduce((a, b) => a + b, 0) / filteredAmounts.length : 0;
            const sortedAmounts = [...filteredAmounts].sort((a, b) => a - b);
            const median = sortedAmounts.length > 0 ? 
                (sortedAmounts.length % 2 === 0 
                    ? (sortedAmounts[sortedAmounts.length/2 - 1] + sortedAmounts[sortedAmounts.length/2]) / 2 
                    : sortedAmounts[Math.floor(sortedAmounts.length/2)]) 
                : 0;
            
            updateStatsDisplay(result.summary.count, avg, median, result.summary.total_spent);
            
            renderTransactions(result.transactions);
            
            // Update pie chart with filtered data (unless skipped due to pie chart click)
            if (pieChart && result.transactions.length > 0 && !window._skipPieChartUpdate) {
                updatePieChartWithFilteredData(result.transactions);
            }
            // Reset the skip flag
            window._skipPieChartUpdate = false;
        } catch (error) {
            console.error('Error applying filters:', error);
            window._skipPieChartUpdate = false;
        }
    }
    
    function updatePieChartWithFilteredData(transactions) {
        // Calculate breakdown from filtered transactions
        const expenses = transactions.filter(t => t.amount < 0);
        if (expenses.length === 0) {
            pieChart.data.labels = [];
            pieChart.data.datasets[0].data = [];
            pieChart.update();
            return;
        }
        
        let labels = [], data = [], bgColors = [];
        
        if (currentPieFilter === 'category') {
            const catTotals = {};
            expenses.forEach(t => {
                const cat = t.category || 'Other';
                // Skip "Unknown" and "Other" placeholder categories
                if (cat !== 'Unknown' && cat !== 'Other') {
                    catTotals[cat] = (catTotals[cat] || 0) + Math.abs(t.amount);
                }
            });
            const sorted = Object.entries(catTotals).sort((a, b) => b[1] - a[1]);
            sorted.forEach(([cat, total], i) => {
                labels.push(cat);
                data.push(total);
                bgColors.push(categoryColors[cat] || colors[i % colors.length]);
            });
        } else if (currentPieFilter === 'necessity') {
            const necTotals = {};
            expenses.forEach(t => {
                const nec = t.necessity || 'Unknown';
                // Skip "Unknown" placeholder
                if (nec !== 'Unknown') {
                    necTotals[nec] = (necTotals[nec] || 0) + Math.abs(t.amount);
                }
            });
            const localNecessityColors = { 'Needs': '#3b82f6', 'Flexible Need': '#60a5fa', 'Wants': '#ec4899', 'Savings': '#22c55e', 'Unknown': '#64748b' };
            const sorted = Object.entries(necTotals).sort((a, b) => b[1] - a[1]);
            sorted.forEach(([type, total], i) => {
                labels.push(type);
                data.push(total);
                bgColors.push(localNecessityColors[type] || colors[i % colors.length]);
            });
        } else if (currentPieFilter === 'recurrence') {
            const recTotals = {};
            expenses.forEach(t => {
                const rec = t.recurrence || 'Unknown';
                // Skip "Unknown" placeholder
                if (rec !== 'Unknown') {
                    recTotals[rec] = (recTotals[rec] || 0) + Math.abs(t.amount);
                }
            });
            const localRecurrenceColors = { 'Subscription': '#a855f7', 'Recurring': '#14b8a6', 'One-time': '#64748b', 'Unknown': '#94a3b8' };
            const sorted = Object.entries(recTotals).sort((a, b) => b[1] - a[1]);
            sorted.forEach(([type, total], i) => {
                labels.push(type);
                data.push(total);
                bgColors.push(localRecurrenceColors[type] || colors[i % colors.length]);
            });
        } else if (currentPieFilter === 'transactions') {
            // Top transactions
            const sortedTx = [...expenses].sort((a, b) => Math.abs(b.amount) - Math.abs(a.amount)).slice(0, 10);
            sortedTx.forEach((t, i) => {
                const label = t.description.length > 25 ? t.description.substring(0, 22) + '...' : t.description;
                labels.push(label);
                data.push(Math.abs(t.amount));
                bgColors.push(colors[i % colors.length]);
            });
        } else if (currentPieFilter === 'bank') {
            const bankTotals = {};
            expenses.forEach(t => {
                const bank = t.bank || 'Unknown';
                bankTotals[bank] = (bankTotals[bank] || 0) + Math.abs(t.amount);
            });
            const bankColors = { 'chase': '#003087', 'discover': '#FF6000', 'Unknown': '#64748b' };
            const sorted = Object.entries(bankTotals).sort((a, b) => b[1] - a[1]);
            sorted.forEach(([bank, total], i) => {
                labels.push(bank.charAt(0).toUpperCase() + bank.slice(1));
                data.push(total);
                bgColors.push(bankColors[bank] || colors[i % colors.length]);
            });
        }
        
        pieChart.data.labels = labels;
        pieChart.data.datasets[0].data = data;
        pieChart.data.datasets[0].backgroundColor = bgColors;
        pieChart.update();
    }
    
    function formatDateShort(dateStr) {
        const date = new Date(dateStr + 'T12:00:00');
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function formatDate(dateStr) {
        if (!dateStr) return '';
        const date = new Date(dateStr + 'T12:00:00');
        if (isNaN(date.getTime())) return dateStr;
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    }
    
    // =========================================================================
    // CATEGORY RULES MANAGEMENT
    // =========================================================================
    
    let categoryRules = [];
    let newRuleKeywords = [];
    let editingRuleId = null;
    
    // Load rules on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadCategoryRules();
        setupKeywordInput();
        setupSearchBar();
    });
    
    // =================== SEARCH BAR ===================
    let searchKeywords = [];
    let isSearchExpanded = false;
    
    function setupSearchBar() {
        const input = document.getElementById('searchInput');
        
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                e.preventDefault();
                addSearchKeyword(this.value.trim());
                this.value = '';
            } else if (e.key === 'Backspace' && !this.value && searchKeywords.length > 0) {
                removeSearchKeyword(searchKeywords.length - 1);
            } else if (e.key === 'Escape') {
                if (searchKeywords.length === 0) {
                    toggleSearchBar();
                }
            }
        });
    }
    
    function toggleSearchBar() {
        const wrapper = document.getElementById('searchInputWrapper');
        const btn = document.getElementById('searchToggleBtn');
        const input = document.getElementById('searchInput');
        
        isSearchExpanded = !isSearchExpanded;
        
        if (isSearchExpanded) {
            wrapper.classList.add('expanded');
            btn.classList.add('active');
            setTimeout(() => input.focus(), 300);
        } else {
            wrapper.classList.remove('expanded');
            btn.classList.remove('active');
            if (searchKeywords.length === 0) {
                input.value = '';
            }
        }
    }
    
    function addSearchKeyword(keyword) {
        if (!searchKeywords.includes(keyword.toLowerCase())) {
            searchKeywords.push(keyword);
            renderSearchKeywords();
            applySearchFilter();
        }
    }
    
    function removeSearchKeyword(index) {
        searchKeywords.splice(index, 1);
        renderSearchKeywords();
        applySearchFilter();
    }
    
    function renderSearchKeywords() {
        const container = document.getElementById('searchKeywords');
        const clearBtn = document.getElementById('searchClearBtn');
        
        if (searchKeywords.length === 0) {
            container.innerHTML = '';
            clearBtn.style.display = 'none';
            return;
        }
        
        clearBtn.style.display = 'flex';
        container.innerHTML = searchKeywords.map((kw, i) => `
            ${i > 0 ? '<span class="search-and-connector">AND</span>' : ''}
            <span class="search-keyword-tag">${escapeHtml(kw)}<span class="remove" onclick="removeSearchKeyword(${i})">×</span></span>
        `).join('');
    }
    
    function clearSearch() {
        searchKeywords = [];
        document.getElementById('searchInput').value = '';
        renderSearchKeywords();
        applySearchFilter();
    }
    
    function applySearchFilter() {
        if (searchKeywords.length === 0) {
            // No search filter - show transactions based on timeframe
            syncTransactionsToTimeframe();
            return;
        }
        
        // Filter displayed transactions by search keywords (AND logic)
        const filtered = displayedTransactions.filter(t => {
            const desc = t.description.toLowerCase();
            return searchKeywords.every(kw => desc.includes(kw.toLowerCase()));
        });
        
        // Update title to show search is active
        document.getElementById('transactionsTitle').textContent = `Search Results (${filtered.length})`;
        
        renderTransactions(filtered);
        
        // Update stats for filtered results
        const amounts = filtered.filter(t => t.amount < 0 || t.type === 'expense').map(t => Math.abs(t.amount));
        const total = amounts.reduce((a, b) => a + b, 0);
        const avg = amounts.length > 0 ? total / amounts.length : 0;
        const sortedAmounts = [...amounts].sort((a, b) => a - b);
        const median = sortedAmounts.length > 0 ? 
            (sortedAmounts.length % 2 === 0 
                ? (sortedAmounts[sortedAmounts.length/2 - 1] + sortedAmounts[sortedAmounts.length/2]) / 2 
                : sortedAmounts[Math.floor(sortedAmounts.length/2)]) 
            : 0;
        
        updateStatsDisplay(filtered.length, avg, median, total);
    }
    
    function toggleRulesPanel() {
        document.getElementById('rulesPanel').classList.toggle('open');
        document.getElementById('panelOverlay').classList.toggle('show');
    }
    
    function closeRulesPanel() {
        document.getElementById('rulesPanel').classList.remove('open');
        document.getElementById('panelOverlay').classList.remove('show');
    }
    
    async function loadCategoryRules() {
        try {
            const response = await fetch('/api/category-rules');
            const data = await response.json();
            categoryRules = data.rules || [];
            renderRulesList();
        } catch (error) {
            console.error('Error loading rules:', error);
        }
    }
    
    async function runAllRules() {
        if (categoryRules.length === 0) {
            alert('No rules to apply.');
            return;
        }
        
        const btn = document.querySelector('.btn-run-all:not(.sweep)');
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '⏳ Running...';
        
        try {
            const response = await fetch('/api/category-rules/apply-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (data.success) {
                await loadAllTransactions();
                syncTransactionsToTimeframe();
                if (typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                alert(`Applied all rules! ${data.transactions_updated || 0} transaction(s) updated.`);
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }
    
    function renderRulesList() {
        const container = document.getElementById('rulesList');
        
        if (categoryRules.length === 0) {
            container.innerHTML = `
                <div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">
                    No rules yet. Create one above!
                </div>
            `;
            return;
        }
        
        const fieldLabels = {
            'category': '',
            'necessity': '',
            'recurrence': ''
        };
        
        container.innerHTML = categoryRules.map(rule => {
            // Support both new multi-tag format and legacy format
            const tags = rule.tags || {[rule.field || 'category']: rule.category};
            const tagBadges = Object.entries(tags)
                .filter(([k, v]) => v)
                .map(([field, value]) => `<span class="rule-tag-badge">${fieldLabels[field] || ''} ${escapeHtml(value)}</span>`)
                .join(' ');
            
            return `
            <div class="rule-item ${rule.enabled ? '' : 'disabled'}">
                <div class="rule-item-header">
                    <div class="rule-tags">${tagBadges}</div>
                    <div class="rule-actions">
                        <button class="btn-toggle-rule" onclick="toggleRule('${rule.id}')" title="${rule.enabled ? 'Disable' : 'Enable'}">
                            ${rule.enabled ? '✓' : '○'}
                        </button>
                        <button class="btn-edit-rule" onclick="editRule('${rule.id}')" title="Edit">✎</button>
                        <button class="btn-delete-rule" onclick="deleteRule('${rule.id}')" title="Delete">✕</button>
                    </div>
                </div>
                <div class="rule-keywords">
                    ${rule.keywords.map((kw, i) => `
                        ${i > 0 ? '<span class="and-connector">AND</span>' : ''}
                        <span class="rule-keyword">${escapeHtml(kw)}</span>
                    `).join('')}
                </div>
            </div>
        `}).join('');
    }
    
    function setupKeywordInput() {
        const input = document.getElementById('keywordInput');
        const wrapper = document.getElementById('keywordsWrapper');
        const categoryInput = document.getElementById('ruleCategory');
        const categoryAutocomplete = document.getElementById('ruleCategoryAutocomplete');
        
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                e.preventDefault();
                addKeyword(this.value.trim());
                this.value = '';
            } else if (e.key === 'Backspace' && !this.value && newRuleKeywords.length > 0) {
                removeKeyword(newRuleKeywords.length - 1);
            }
        });
        
        input.addEventListener('input', debounce(previewRule, 500));
        
        // Setup category autocomplete in rules panel
        categoryInput.addEventListener('input', function() {
            refreshKnownCategories();
            showCategoryAutocomplete(categoryAutocomplete, this.value.toLowerCase(), (cat) => {
                categoryInput.value = cat;
                categoryAutocomplete.classList.remove('show');
            });
        });
        
        categoryInput.addEventListener('blur', function() {
            setTimeout(() => categoryAutocomplete.classList.remove('show'), 200);
        });
        
        categoryInput.addEventListener('focus', function() {
            if (this.value) {
                refreshKnownCategories();
                showCategoryAutocomplete(categoryAutocomplete, this.value.toLowerCase(), (cat) => {
                    categoryInput.value = cat;
                    categoryAutocomplete.classList.remove('show');
                });
            }
        });
    }
    
    function addKeyword(keyword) {
        if (!newRuleKeywords.includes(keyword.toLowerCase())) {
            newRuleKeywords.push(keyword);
            renderKeywords();
            previewRule();
        }
    }
    
    function removeKeyword(index) {
        newRuleKeywords.splice(index, 1);
        renderKeywords();
        previewRule();
    }
    
    function renderKeywords() {
        const wrapper = document.getElementById('keywordsWrapper');
        const input = document.getElementById('keywordInput');
        
        // Remove existing tags
        wrapper.querySelectorAll('.keyword-tag, .and-connector').forEach(el => el.remove());
        
        // Add keyword tags before input
        newRuleKeywords.forEach((kw, i) => {
            if (i > 0) {
                const connector = document.createElement('span');
                connector.className = 'and-connector';
                connector.textContent = 'AND';
                wrapper.insertBefore(connector, input);
            }
            
            const tag = document.createElement('span');
            tag.className = 'keyword-tag';
            tag.innerHTML = `${escapeHtml(kw)}<span class="remove" onclick="removeKeyword(${i})">×</span>`;
            wrapper.insertBefore(tag, input);
        });
    }
    
    async function previewRule() {
        const previewSection = document.getElementById('previewSection');
        
        if (newRuleKeywords.length === 0) {
            previewSection.style.display = 'none';
            return;
        }
        
        try {
            const response = await fetch('/api/category-rules/preview', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ keywords: newRuleKeywords })
            });
            const data = await response.json();
            
            previewSection.style.display = 'block';
            document.getElementById('previewCount').textContent = data.matching_count;
            
            const matchesContainer = document.getElementById('previewMatches');
            if (data.matches.length > 0) {
                // Show all matching transactions
                matchesContainer.innerHTML = data.matches.map(m => 
                    `<div class="preview-match">• ${escapeHtml(m.description.substring(0, 70))}${m.description.length > 70 ? '...' : ''}</div>`
                ).join('');
            } else {
                matchesContainer.innerHTML = '<div class="preview-match" style="color: var(--text-light);">No matching transactions</div>';
            }
        } catch (error) {
            console.error('Preview error:', error);
        }
    }
    
    function resetRuleForm() {
        document.getElementById('ruleCategory').value = '';
        document.getElementById('ruleNecessity').value = '';
        document.getElementById('ruleRecurrence').value = '';
        document.getElementById('keywordInput').value = '';
        newRuleKeywords = [];
        editingRuleId = null;
        renderKeywords();
        document.getElementById('previewSection').style.display = 'none';
        document.querySelector('#ruleForm h4').textContent = 'Create New Rule';
    }
    
    async function saveRule() {
        const category = document.getElementById('ruleCategory').value.trim();
        const necessity = document.getElementById('ruleNecessity').value;
        const recurrence = document.getElementById('ruleRecurrence').value;
        
        // Build tags object with only non-empty values
        const tags = {};
        if (category) tags.category = category;
        if (necessity) tags.necessity = necessity;
        if (recurrence) tags.recurrence = recurrence;
        
        if (Object.keys(tags).length === 0) {
            alert('Please set at least one tag (Category, Necessity, or Recurrence).');
            return;
        }
        
        if (newRuleKeywords.length === 0) {
            alert('Please add at least one keyword');
            return;
        }
        
        try {
            let response;
            if (editingRuleId) {
                response = await fetch(`/api/category-rules/${editingRuleId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tags, keywords: newRuleKeywords })
                });
            } else {
                response = await fetch('/api/category-rules', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ tags, keywords: newRuleKeywords })
                });
            }
            
            const data = await response.json();
            
            if (data.success) {
                resetRuleForm();
                await loadCategoryRules();
                await loadAllTransactions(); // Refresh transactions to show new categories
                
                // Preserve the current timeframe filter after reloading transactions
                syncTransactionsToTimeframe();
                
                // Mark as unsynced since transactions were updated
                if (data.transactions_updated && data.transactions_updated > 0 && typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                if (data.transactions_updated && data.transactions_updated > 0) {
                    alert(`Rule saved! ${data.transactions_updated} transaction(s) have been updated.`);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Save error:', error);
            alert('Error saving rule');
        }
    }
    
    function editRule(ruleId) {
        const rule = categoryRules.find(r => r.id === ruleId);
        if (!rule) return;
        
        editingRuleId = ruleId;
        document.getElementById('ruleCategory').value = rule.category;
        newRuleKeywords = [...rule.keywords];
        renderKeywords();
        previewRule();
        document.querySelector('#ruleForm h4').textContent = '✏️ Edit Rule';
        
        // Scroll to form
        document.getElementById('ruleForm').scrollIntoView({ behavior: 'smooth' });
    }
    
    async function deleteRule(ruleId) {
        if (!confirm('Delete this rule?')) return;
        
        try {
            const response = await fetch(`/api/category-rules/${ruleId}`, {
                method: 'DELETE'
            });
            const data = await response.json();
            
            if (data.success) {
                await loadCategoryRules();
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Delete error:', error);
        }
    }
    
    async function toggleRule(ruleId) {
        const rule = categoryRules.find(r => r.id === ruleId);
        if (!rule) return;
        
        try {
            const response = await fetch(`/api/category-rules/${ruleId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !rule.enabled })
            });
            
            if (response.ok) {
                await loadCategoryRules();
            }
        } catch (error) {
            console.error('Toggle error:', error);
        }
    }
    
    // =========================================================================
    // INLINE CATEGORY EDITING
    // =========================================================================
    
    let activeDropdown = null;
    let activeDropdownData = null;
    let activeTagType = null;
    let inlineRuleKeywords = [];
    const knownCategories = new Set();
    const knownNecessities = new Set(['Needs', 'Flexible Need', 'Wants', 'Savings']);
    const knownRecurrences = new Set(['Subscription', 'Recurring', 'One-time']);
    
    // Get necessity options - Income category transactions don't have necessity
    function getNecessityOptions(transaction) {
        const isIncomeCategory = transaction && (transaction.category || '').toLowerCase() === 'income';
        // Income category doesn't have Needs/Wants/Savings/Flexible Need
        return isIncomeCategory ? [] : ['Needs', 'Flexible Need', 'Wants', 'Savings'];
    }
    
    // Get recurrence options - same for all transactions
    function getRecurrenceOptions(transaction) {
        return ['Subscription', 'Recurring', 'One-time'];
    }
    
    // Collect known categories, recurrences, and necessities from transactions
    function refreshKnownCategories() {
        allTransactions.forEach(t => {
            if (t.category) knownCategories.add(t.category);
            if (t.recurrence) knownRecurrences.add(t.recurrence);
            if (t.necessity) knownNecessities.add(t.necessity);
        });
        // Also add categories from existing rules
        categoryRules.forEach(r => {
            if (r.category) knownCategories.add(r.category);
        });
    }
    
    function openTagEdit(element, transaction, tagType, currentValue) {
        // Close any open dropdown
        closeCategoryDropdown();
        refreshKnownCategories();
        
        activeDropdownData = transaction;
        activeTagType = tagType;
        inlineRuleKeywords = [];
        
        // Get position - place dropdown to the left of clicked element
        const rect = element.getBoundingClientRect();
        const dropdownWidth = 520; // Wide layout
        let left = rect.left - dropdownWidth - 10;
        let top = rect.top;
        
        // If would go off left side, position to right instead
        if (left < 10) {
            left = rect.right + 10;
        }
        
        // If still goes off right side, center it
        if (left + dropdownWidth > window.innerWidth - 10) {
            left = Math.max(10, (window.innerWidth - dropdownWidth) / 2);
        }
        
        // Ensure it doesn't go off bottom of screen
        const maxHeight = 420;
        if (top + maxHeight > window.innerHeight) {
            top = window.innerHeight - maxHeight - 10;
        }
        if (top < 10) top = 10;
        
        // Create dropdown
        const dropdown = document.createElement('div');
        dropdown.className = 'category-dropdown show wide';
        dropdown.style.left = left + 'px';
        dropdown.style.top = top + 'px';
        
        // Different content based on tag type
        if (tagType === 'category') {
            dropdown.innerHTML = buildCategoryEditHTML(transaction, currentValue);
        } else if (tagType === 'necessity') {
            dropdown.innerHTML = buildNecessityEditHTML(transaction, currentValue);
        } else if (tagType === 'recurrence') {
            dropdown.innerHTML = buildRecurrenceEditHTML(transaction, currentValue);
        }
        
        // Append to body (not to wrapper) so it's not clipped
        document.body.appendChild(dropdown);
        activeDropdown = dropdown;
        
        // Setup event handlers - all types now have rule creation
        setupInlineDropdown(dropdown, transaction);
        setupSimpleTagDropdown(dropdown, transaction, tagType);
        
        // Focus appropriate input
        if (tagType === 'category') {
            const input = dropdown.querySelector('#inlineCategoryInput');
            if (input) { input.focus(); input.select(); }
        }
        
        // Close when clicking outside
        setTimeout(() => {
            document.addEventListener('click', closeCategoryDropdownOutside);
        }, 0);
    }
    
    function buildCategoryEditHTML(transaction, currentValue) {
        return `
            <div class="dropdown-columns">
                <!-- Left: Rule Creation with Multi-Tag -->
                <div class="dropdown-column rule-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Create Auto-Tag Rule</div>
                        <p style="font-size: 0.6rem; color: var(--text-secondary); margin: 0 0 0.35rem 0;">Set multiple tags at once!</p>
                        <div class="inline-rule-form">
                            <div class="inline-multi-tag-row">
                                <div class="rule-form-group">
                                    <label>Category</label>
                                    <div class="input-with-autocomplete">
                                        <input type="text" id="inlineRuleCategory" placeholder="e.g., Hobby" autocomplete="off">
                                        <div class="autocomplete-list" id="inlineRuleCategoryAutocomplete"></div>
                                    </div>
                                </div>
                                <div class="rule-form-group">
                                    <label>Necessity</label>
                                    <select id="inlineRuleNecessity" style="width: 100%; padding: 0.3rem; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.68rem;">
                                        <option value="">— Skip —</option>
                                        <option value="Needs">Needs</option>
                                        <option value="Flexible Need">Flexible Need</option>
                                        <option value="Wants">Wants</option>
                                        <option value="Savings">Savings</option>
                                    </select>
                                </div>
                                <div class="rule-form-group">
                                    <label>Recurrence</label>
                                    <select id="inlineRuleRecurrence" style="width: 100%; padding: 0.3rem; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.68rem;">
                                        <option value="">— Skip —</option>
                                        <option value="Subscription">Subscription</option>
                                        <option value="Recurring">Recurring</option>
                                        <option value="One-time">One-time</option>
                                    </select>
                                </div>
                            </div>
                            <div class="rule-form-group">
                                <label>Keywords (all must match)</label>
                                <div class="inline-keywords-wrapper" id="inlineKeywordsWrapper">
                                    <input type="text" class="inline-keyword-input" id="inlineKeywordInput" placeholder="Type + Enter...">
                                </div>
                            </div>
                            <div class="inline-preview" id="inlinePreview" style="display: none;">
                                <strong id="inlinePreviewCount">0</strong> transactions will be tagged
                                <div class="inline-preview-matches" id="inlinePreviewMatches"></div>
                            </div>
                            <div class="inline-rule-actions">
                                <button class="btn-save-inline-rule" onclick="saveInlineRule()">Save Rule</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Quick Category Change -->
                <div class="dropdown-column options-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Change Category</div>
                        <div class="input-with-autocomplete">
                            <input type="text" placeholder="Type category..." id="inlineCategoryInput" value="${escapeHtml(currentValue || '')}" autocomplete="off">
                            <div class="autocomplete-list" id="inlineCategoryAutocomplete"></div>
                        </div>
                        <div class="category-options" id="inlineCategoryOptions">
                            ${Array.from(knownCategories).sort().slice(0, 10).map(cat => `
                                <div class="category-option ${cat === currentValue ? 'selected' : ''}" 
                                     data-category="${escapeHtml(cat)}">
                        ${escapeHtml(cat)}
                    </div>
                `).join('')}
            </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function buildNecessityEditHTML(transaction, currentValue) {
        const options = getNecessityOptions(transaction);
        return `
            <div class="dropdown-columns">
                <!-- Left: Rule Creation -->
                <div class="dropdown-column rule-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Create Auto-Tag Rule</div>
                        <div class="inline-rule-form">
                            <div class="rule-form-group">
                                <label>Necessity type to assign</label>
                                <select id="inlineRuleNecessity" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.72rem;">
                                    ${Array.from(knownNecessities).map(val => `<option value="${val}">${val}</option>`).join('')}
                                </select>
                            </div>
                            <div class="rule-form-group">
                                <label>Keywords (all must match)</label>
                                <div class="inline-keywords-wrapper" id="inlineKeywordsWrapper">
                                    <input type="text" class="inline-keyword-input" id="inlineKeywordInput" placeholder="Type + Enter...">
                                </div>
                            </div>
                            <div class="inline-preview" id="inlinePreview" style="display: none;">
                                <strong id="inlinePreviewCount">0</strong> transactions will be tagged
                                <div class="inline-preview-matches" id="inlinePreviewMatches"></div>
                            </div>
                            <div class="inline-rule-actions">
                                <button class="btn-save-inline-rule" onclick="saveInlineFieldRule('necessity')">Save Rule</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Quick Change -->
                <div class="dropdown-column options-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Change Necessity</div>
                        <div class="category-options">
                            ${options.map(val => `
                                <div class="category-option ${val === currentValue ? 'selected' : ''}" 
                                     data-value="${escapeHtml(val)}" data-field="necessity">
                                    <span class="mini-badge ${val.toLowerCase().replace(' ', '')}" style="pointer-events: none;">${val}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function buildRecurrenceEditHTML(transaction, currentValue) {
        const options = getRecurrenceOptions(transaction);
        return `
            <div class="dropdown-columns">
                <!-- Left: Rule Creation -->
                <div class="dropdown-column rule-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Create Auto-Tag Rule</div>
                        <div class="inline-rule-form">
                            <div class="rule-form-group">
                                <label>Recurrence type to assign</label>
                                <select id="inlineRuleRecurrence" style="width: 100%; padding: 0.35rem; border: 1px solid var(--border-color); border-radius: 4px; font-size: 0.72rem;">
                                    ${Array.from(knownRecurrences).map(val => `<option value="${val}">${val}</option>`).join('')}
                                </select>
                            </div>
                            <div class="rule-form-group">
                                <label>Keywords (all must match)</label>
                                <div class="inline-keywords-wrapper" id="inlineKeywordsWrapper">
                                    <input type="text" class="inline-keyword-input" id="inlineKeywordInput" placeholder="Type + Enter...">
                                </div>
                            </div>
                            <div class="inline-preview" id="inlinePreview" style="display: none;">
                                <strong id="inlinePreviewCount">0</strong> transactions will be tagged
                                <div class="inline-preview-matches" id="inlinePreviewMatches"></div>
                            </div>
                            <div class="inline-rule-actions">
                                <button class="btn-save-inline-rule" onclick="saveInlineFieldRule('recurrence')">Save Rule</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Right: Quick Change -->
                <div class="dropdown-column options-column">
                    <div class="dropdown-section">
                        <div class="dropdown-section-title">Change Recurrence</div>
                        <div class="category-options">
                            ${options.map(val => `
                                <div class="category-option ${val === currentValue ? 'selected' : ''}" 
                                     data-value="${escapeHtml(val)}" data-field="recurrence">
                                    <span class="mini-badge ${val.toLowerCase().replace('-', '')}" style="pointer-events: none;">${val}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function setupSimpleTagDropdown(dropdown, transaction, tagType) {
        // Handle clicks on options with data-value and data-field (for necessity/recurrence)
        const options = dropdown.querySelectorAll('.category-option[data-value][data-field]');
        options.forEach(opt => {
            opt.addEventListener('click', async function(e) {
                e.stopPropagation();
                const value = this.dataset.value;
                const field = this.dataset.field;
                if (field && value) {
                    await updateTransactionField(transaction.description, transaction.transaction_date, field, value);
                }
            });
        });
    }
    
    function openAddTagMenu(element, transaction) {
        // Close any open dropdown
        closeCategoryDropdown();
        
        activeDropdownData = transaction;
        activeTagType = 'add';
        inlineRuleKeywords = [];
        
        // Get position
        const rect = element.getBoundingClientRect();
        const dropdownWidth = 520;
        let left = rect.left - dropdownWidth - 10;
        let top = rect.top;
        
        if (left < 10) {
            left = rect.right + 10;
        }
        if (left + dropdownWidth > window.innerWidth - 10) {
            left = Math.max(10, (window.innerWidth - dropdownWidth) / 2);
        }
        
        const maxHeight = 420;
        if (top + maxHeight > window.innerHeight) {
            top = window.innerHeight - maxHeight - 10;
        }
        if (top < 10) top = 10;
        
        // Create dropdown
        const dropdown = document.createElement('div');
        dropdown.className = 'category-dropdown show wide';
        dropdown.style.left = left + 'px';
        dropdown.style.top = top + 'px';
        dropdown.innerHTML = buildAddTagHTML(transaction);
        
        // Store transaction info for custom tag creation
        dropdown.dataset.txDescription = transaction.description;
        dropdown.dataset.txDate = transaction.transaction_date;
        
        document.body.appendChild(dropdown);
        activeDropdown = dropdown;
        
        // Setup handlers
        setupInlineDropdown(dropdown, transaction);
        setupAddTagDropdown(dropdown, transaction);
        setupAddTagFieldAutocomplete(dropdown);
        
        // Automatically switch to Auto-Tag tab
        const tabs = dropdown.querySelectorAll('.tag-popup-tab');
        const contents = dropdown.querySelectorAll('.tag-popup-content');
        tabs.forEach(t => t.classList.remove('active'));
        contents.forEach(c => c.classList.remove('active'));
        const autoTagTab = dropdown.querySelector('.tag-popup-tab[data-tab="auto-tag"]');
        const autoTagContent = dropdown.querySelector('#tab-auto-tag');
        if (autoTagTab) autoTagTab.classList.add('active');
        if (autoTagContent) autoTagContent.classList.add('active');
        
        setTimeout(() => {
            document.addEventListener('click', closeCategoryDropdownOutside);
        }, 0);
    }
    
    function setupAddTagFieldAutocomplete(dropdown) {
        const fieldSelect = dropdown.querySelector('#inlineRuleField');
        const valueInput = dropdown.querySelector('#inlineRuleCategory');
        const valueAutocomplete = dropdown.querySelector('#inlineRuleCategoryAutocomplete');
        
        if (!fieldSelect || !valueInput || !valueAutocomplete) return;
        
        // Update autocomplete when field changes
        fieldSelect.addEventListener('change', function() {
            valueInput.value = '';
            valueAutocomplete.classList.remove('show');
            // Show all options for new field type on focus
            valueInput.focus();
        });
        
        // Show autocomplete based on selected field
        valueInput.addEventListener('input', function() {
            const fieldType = fieldSelect.value;
            const searchTerm = this.value.toLowerCase();
            
            // Show autocomplete even for partial matches
            showCategoryAutocomplete(valueAutocomplete, searchTerm || ' ', (val) => {
                valueInput.value = val;
                valueAutocomplete.classList.remove('show');
            }, fieldType, searchTerm === '');
        });
        
        // Also show options on focus
        valueInput.addEventListener('focus', function() {
            const fieldType = fieldSelect.value;
            const searchTerm = this.value.toLowerCase();
            showCategoryAutocomplete(valueAutocomplete, searchTerm || ' ', (val) => {
                valueInput.value = val;
                valueAutocomplete.classList.remove('show');
            }, fieldType, searchTerm === '');
        });
        
        valueInput.addEventListener('blur', function() {
            setTimeout(() => valueAutocomplete.classList.remove('show'), 200);
        });
    }
    
    function buildAddTagHTML(transaction) {
        const isPositive = transaction && transaction.amount > 0;
        const isIncomeCategory = transaction && (transaction.category || '').toLowerCase() === 'income';
        const currentNote = transaction.note || '';
        const currentNecessity = transaction.necessity || '';
        const currentRecurrence = transaction.recurrence || '';
        const currentCategory = transaction.category || '';
        
        // Get all categories sorted
        const allCategories = Array.from(knownCategories).sort();
        const needsTwoColumns = allCategories.length > 8;
        
        return `
            <!-- Tab Navigation -->
            <div class="tag-popup-tabs">
                <div class="tag-popup-tab active" data-tab="add-tags">Add Tags</div>
                <div class="tag-popup-tab" data-tab="auto-tag">Auto-Tag</div>
                <div class="tag-popup-tab" data-tab="note">Note</div>
            </div>
            
            <!-- Add Tags Tab Content -->
            <div class="tag-popup-content active" id="tab-add-tags">
                <div class="tag-grid ${needsTwoColumns ? 'categories-wide' : ''}">
                    <!-- Category Column(s) -->
                    <div class="tag-column" style="grid-column: span ${needsTwoColumns ? 2 : 1};">
                        <div class="tag-column-title">Category</div>
                        <div class="tag-column-items category-items">
                            ${allCategories.map(cat => `
                                <button class="tag-option-btn ${currentCategory === cat ? 'selected' : ''}" 
                                    data-field="category" data-value="${escapeHtml(cat)}"
                                    title="${escapeHtml(cat)}">
                                    ${escapeHtml(cat)}
                                </button>
                            `).join('')}
                        </div>
                        <div class="add-new-tag-wrapper">
                            <div class="add-new-tag-input">
                                <input type="text" id="newCategoryInput" placeholder="New category..." onclick="event.stopPropagation()">
                                <button class="add-new-tag-btn" onclick="event.stopPropagation(); addNewCustomTag('category')">Add</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Recurrence & Necessity Column -->
                    <div class="tag-column">
                        <div class="tag-column-title">Recurrence</div>
                        <div class="tag-column-items">
                            ${Array.from(knownRecurrences).map(val => `
                                <button class="tag-option-btn ${val.toLowerCase().replace('-', '')} ${currentRecurrence === val ? 'selected' : ''}" 
                                    data-field="recurrence" data-value="${escapeHtml(val)}">
                                    ${val}
                                </button>
                            `).join('')}
                        </div>
                        <div class="add-new-tag-wrapper">
                            <div class="add-new-tag-input">
                                <input type="text" id="newRecurrenceInput" placeholder="New recurrence..." onclick="event.stopPropagation()">
                                <button class="add-new-tag-btn" onclick="event.stopPropagation(); addNewCustomTag('recurrence')">Add</button>
                            </div>
                        </div>
                        
                        ${!isIncomeCategory ? `
                            <div class="tag-column-title" style="margin-top: 0.75rem;">Necessity</div>
                            <div class="tag-column-items">
                                ${Array.from(knownNecessities).map(val => `
                                    <button class="tag-option-btn ${val.toLowerCase().replace(' ', '')} ${currentNecessity === val ? 'selected' : ''}" 
                                        data-field="necessity" data-value="${escapeHtml(val)}">
                                        ${val}
                                    </button>
                                `).join('')}
                            </div>
                            <div class="add-new-tag-wrapper">
                                <div class="add-new-tag-input">
                                    <input type="text" id="newNecessityInput" placeholder="New necessity..." onclick="event.stopPropagation()">
                                    <button class="add-new-tag-btn" onclick="event.stopPropagation(); addNewCustomTag('necessity')">Add</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
            
            <!-- Auto-Tag Tab Content -->
            <div class="tag-popup-content" id="tab-auto-tag">
                <div class="auto-tag-columns">
                    <!-- Left: Affected Transactions Preview -->
                    <div class="auto-tag-preview-column">
                        <div class="dropdown-section-title">Affected Transactions</div>
                        <div class="inline-preview" id="inlinePreview">
                            <div class="inline-preview-placeholder">
                                Add keywords to see matching transactions
                            </div>
                            <div class="inline-preview-content" style="display: none;">
                                <strong id="inlinePreviewCount">0</strong> transactions will be tagged
                                <div class="inline-preview-matches" id="inlinePreviewMatches"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right: Rule Creation Form -->
                    <div class="auto-tag-form-column">
                        <div class="dropdown-section-title">Create Auto-Tag Rule</div>
                        <p style="font-size: 0.6rem; color: var(--text-secondary); margin: 0 0 0.35rem 0;">Set multiple tags at once!</p>
                        <div class="inline-rule-form">
                            <div class="inline-multi-tag-row">
                                <div class="rule-form-group">
                                    <label>Category</label>
                                    <div class="input-with-autocomplete">
                                        <input type="text" id="inlineRuleCategory" placeholder="e.g., Hobby" autocomplete="off">
                                        <div class="autocomplete-list" id="inlineRuleCategoryAutocomplete"></div>
                                    </div>
                                </div>
                                <div class="rule-form-group">
                                    <label>Necessity</label>
                                    <select id="inlineRuleNecessity">
                                        <option value="">— Skip —</option>
                                        <option value="Needs">Needs</option>
                                        <option value="Flexible Need">Flexible Need</option>
                                        <option value="Wants">Wants</option>
                                        <option value="Savings">Savings</option>
                                    </select>
                                </div>
                                <div class="rule-form-group">
                                    <label>Recurrence</label>
                                    <select id="inlineRuleRecurrence">
                                        <option value="">— Skip —</option>
                                        <option value="Subscription">Subscription</option>
                                        <option value="Recurring">Recurring</option>
                                        <option value="One-time">One-time</option>
                                    </select>
                                </div>
                            </div>
                            <div class="rule-form-group">
                                <label>Keywords (all must match)</label>
                                <div class="inline-keywords-wrapper" id="inlineKeywordsWrapper">
                                    <input type="text" class="inline-keyword-input" id="inlineKeywordInput" placeholder="Type + Enter...">
                                </div>
                            </div>
                            <div class="inline-rule-actions">
                                <button class="btn-save-inline-rule" onclick="saveAddTagRule()">Save Rule</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Note Tab Content -->
            <div class="tag-popup-content" id="tab-note">
                <div class="dropdown-section">
                    <div class="dropdown-section-title">Transaction Note</div>
                    <div class="note-input-wrapper">
                        <textarea class="note-textarea" id="transactionNoteInput" 
                            placeholder="Add a personal note for this transaction...">${escapeHtml(currentNote)}</textarea>
                        <div class="note-actions">
                            ${currentNote ? `<button class="btn-clear-note" onclick="clearTransactionNote()">Clear</button>` : ''}
                            <button class="btn-save-note" onclick="saveTransactionNote()">Save Note</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    function setupAddTagDropdown(dropdown, transaction) {
        // Tab switching
        const tabs = dropdown.querySelectorAll('.tag-popup-tab');
        const contents = dropdown.querySelectorAll('.tag-popup-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', function(e) {
                e.stopPropagation();
                const targetTab = this.dataset.tab;
                
                // Update active tab
                tabs.forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Update active content
                contents.forEach(c => c.classList.remove('active'));
                const targetContent = dropdown.querySelector(`#tab-${targetTab}`);
                if (targetContent) {
                    targetContent.classList.add('active');
                }
            });
        });
        
        // Handle tag option buttons (single-select per field type)
        const tagButtons = dropdown.querySelectorAll('.tag-option-btn[data-value][data-field]');
        tagButtons.forEach(btn => {
            btn.addEventListener('click', async function(e) {
                e.stopPropagation();
                const value = this.dataset.value;
                const field = this.dataset.field;
                
                if (field && value) {
                    // Remove 'selected' from other buttons of the same field type
                    dropdown.querySelectorAll(`.tag-option-btn[data-field="${field}"]`).forEach(b => {
                        b.classList.remove('selected');
                    });
                    // Mark this one as selected
                    this.classList.add('selected');
                    
                    // Update the transaction
                    await updateTransactionField(transaction.description, transaction.transaction_date, field, value);
                }
            });
        });
        
        // Legacy support for old category-option elements
        const options = dropdown.querySelectorAll('.category-option[data-value][data-field]');
        options.forEach(opt => {
            opt.addEventListener('click', async function(e) {
                e.stopPropagation();
                const value = this.dataset.value;
                const field = this.dataset.field;
                if (field && value) {
                    await updateTransactionField(transaction.description, transaction.transaction_date, field, value);
                }
            });
        });
        
        // Setup Enter key support for custom tag inputs
        const customTagInputs = [
            { id: 'newCategoryInput', field: 'category' },
            { id: 'newRecurrenceInput', field: 'recurrence' },
            { id: 'newNecessityInput', field: 'necessity' }
        ];
        
        customTagInputs.forEach(({ id, field }) => {
            const input = dropdown.querySelector(`#${id}`);
            if (input) {
                input.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.stopPropagation();
                        addNewCustomTag(field);
                    }
                });
            }
        });
    }
    
    // Add new custom tag for category, recurrence, or necessity
    async function addNewCustomTag(fieldType) {
        let inputId, knownSet;
        
        if (fieldType === 'category') {
            inputId = 'newCategoryInput';
            knownSet = knownCategories;
        } else if (fieldType === 'recurrence') {
            inputId = 'newRecurrenceInput';
            knownSet = knownRecurrences;
        } else if (fieldType === 'necessity') {
            inputId = 'newNecessityInput';
            knownSet = knownNecessities;
        } else {
            return;
        }
        
        const input = document.getElementById(inputId);
        if (!input) return;
        
        const newValue = input.value.trim();
        if (!newValue) {
            input.focus();
            return;
        }
        
        // Check if value already exists (case-insensitive)
        const existingValues = Array.from(knownSet).map(v => v.toLowerCase());
        if (existingValues.includes(newValue.toLowerCase())) {
            alert(`"${newValue}" already exists!`);
            input.value = '';
            input.focus();
            return;
        }
        
        // Add to the known set
        knownSet.add(newValue);
        
        // Get the current transaction from the dropdown context
        const dropdown = input.closest('.category-dropdown');
        if (!dropdown) return;
        
        // Find the tag-column-items container and add the new button
        let container;
        if (fieldType === 'category') {
            container = dropdown.querySelector('.tag-column-items.category-items');
        } else if (fieldType === 'recurrence') {
            // Get the first tag-column-items that's not category-items in the recurrence column
            const recurrenceColumn = dropdown.querySelectorAll('.tag-column')[1];
            if (recurrenceColumn) {
                container = recurrenceColumn.querySelector('.tag-column-items:first-of-type');
            }
        } else if (fieldType === 'necessity') {
            // Get the last tag-column-items in the column (necessity section)
            const recurrenceColumn = dropdown.querySelectorAll('.tag-column')[1];
            if (recurrenceColumn) {
                const items = recurrenceColumn.querySelectorAll('.tag-column-items');
                container = items[items.length - 1];
            }
        }
        
        if (container) {
            // Create the new button element
            const newBtn = document.createElement('button');
            newBtn.className = 'tag-option-btn selected';
            newBtn.setAttribute('data-field', fieldType);
            newBtn.setAttribute('data-value', newValue);
            newBtn.title = newValue;
            newBtn.textContent = newValue;
            
            // Remove 'selected' from other buttons of the same field type
            dropdown.querySelectorAll(`.tag-option-btn[data-field="${fieldType}"]`).forEach(b => {
                b.classList.remove('selected');
            });
            
            // Add click handler
            newBtn.addEventListener('click', async function(e) {
                e.stopPropagation();
                dropdown.querySelectorAll(`.tag-option-btn[data-field="${fieldType}"]`).forEach(b => {
                    b.classList.remove('selected');
                });
                this.classList.add('selected');
                
                // Get transaction info from data attributes
                const txDesc = dropdown.dataset.txDescription;
                const txDate = dropdown.dataset.txDate;
                if (txDesc && txDate) {
                    await updateTransactionField(txDesc, txDate, fieldType, newValue);
                }
            });
            
            // Add the button to the container
            container.appendChild(newBtn);
            
            // Update the transaction with the new value
            const txDesc = dropdown.dataset.txDescription;
            const txDate = dropdown.dataset.txDate;
            if (txDesc && txDate) {
                await updateTransactionField(txDesc, txDate, fieldType, newValue);
            }
        }
        
        // Clear the input
        input.value = '';
    }
    
    async function saveAddTagRule() {
        const categoryInput = document.getElementById('inlineRuleCategory');
        const necessitySelect = document.getElementById('inlineRuleNecessity');
        const recurrenceSelect = document.getElementById('inlineRuleRecurrence');
        
        const category = categoryInput ? categoryInput.value.trim() : '';
        const necessity = necessitySelect ? necessitySelect.value : '';
        const recurrence = recurrenceSelect ? recurrenceSelect.value : '';
        
        // Build tags object with only non-empty values
        const tags = {};
        if (category) tags.category = category;
        if (necessity) tags.necessity = necessity;
        if (recurrence) tags.recurrence = recurrence;
        
        if (Object.keys(tags).length === 0) {
            alert('Please set at least one tag (Category, Necessity, or Recurrence).');
            return;
        }
        
        if (inlineRuleKeywords.length === 0) {
            alert('Please add at least one keyword');
            return;
        }
        
        try {
            const response = await fetch('/api/category-rules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tags, keywords: inlineRuleKeywords })
            });
            
            const data = await response.json();
            
            if (data.success) {
                closeCategoryDropdown();
                await loadCategoryRules();
                await loadAllTransactions();
                
                // Preserve the current timeframe filter after reloading transactions
                syncTransactionsToTimeframe();
                
                if (data.transactions_updated > 0) {
                    alert(`Rule created! ${data.transactions_updated} transaction(s) updated.`);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Save error:', error);
            alert('Error saving rule');
        }
    }
    
    async function saveTransactionNote() {
        if (!activeDropdownData) return;
        
        const noteInput = document.getElementById('transactionNoteInput');
        const note = noteInput ? noteInput.value.trim() : '';
        
        try {
            await updateTransactionField(
                activeDropdownData.description, 
                activeDropdownData.transaction_date, 
                'note', 
                note
            );
            closeCategoryDropdown();
        } catch (error) {
            console.error('Error saving note:', error);
            alert('Error saving note');
        }
    }
    
    async function clearTransactionNote() {
        if (!activeDropdownData) return;
        
        const noteInput = document.getElementById('transactionNoteInput');
        if (noteInput) {
            noteInput.value = '';
        }
        
        try {
            await updateTransactionField(
                activeDropdownData.description, 
                activeDropdownData.transaction_date, 
                'note', 
                ''
            );
            closeCategoryDropdown();
        } catch (error) {
            console.error('Error clearing note:', error);
            alert('Error clearing note');
        }
    }
    
    function setupInlineDropdown(dropdown, transaction) {
        const categoryInput = dropdown.querySelector('#inlineCategoryInput');
        const categoryOptions = dropdown.querySelector('#inlineCategoryOptions');
        const categoryAutocomplete = dropdown.querySelector('#inlineCategoryAutocomplete');
        const ruleCategory = dropdown.querySelector('#inlineRuleCategory');
        const ruleCategoryAutocomplete = dropdown.querySelector('#inlineRuleCategoryAutocomplete');
        const keywordInput = dropdown.querySelector('#inlineKeywordInput');
        const keywordsWrapper = dropdown.querySelector('#inlineKeywordsWrapper');
        
        // Category input - filter options and show autocomplete (only for category type)
        if (categoryInput && categoryOptions && categoryAutocomplete) {
            categoryInput.addEventListener('input', function() {
                const search = this.value.toLowerCase();
                showCategoryAutocomplete(categoryAutocomplete, search, (cat) => {
                    categoryInput.value = cat;
                    saveTransactionCategory(transaction.description, transaction.transaction_date, cat);
                });
                
                // Also filter the options list
                const options = categoryOptions.querySelectorAll('.category-option');
                options.forEach(opt => {
                    const matches = opt.textContent.toLowerCase().includes(search);
                    opt.style.display = matches ? 'block' : 'none';
                });
            });
            
            categoryInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    saveTransactionCategory(transaction.description, transaction.transaction_date, this.value.trim());
                } else if (e.key === 'Escape') {
                    closeCategoryDropdown();
                }
            });
            
            // Category options click - only for category editing (uses data-category)
            categoryOptions.addEventListener('click', function(e) {
                const option = e.target.closest('.category-option');
                if (option && option.dataset.category) {
                    const cat = option.dataset.category;
                    saveTransactionCategory(transaction.description, transaction.transaction_date, cat);
                }
            });
        }
        
        // Rule category autocomplete
        if (ruleCategory && ruleCategoryAutocomplete) {
            ruleCategory.addEventListener('input', function() {
                showCategoryAutocomplete(ruleCategoryAutocomplete, this.value.toLowerCase(), (cat) => {
                    ruleCategory.value = cat;
                    ruleCategoryAutocomplete.classList.remove('show');
                });
            });
            
            ruleCategory.addEventListener('blur', function() {
                setTimeout(() => ruleCategoryAutocomplete.classList.remove('show'), 200);
            });
        }
        
        // Keywords input
        if (keywordInput) {
            keywordInput.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && this.value.trim()) {
                    e.preventDefault();
                    addInlineKeyword(this.value.trim());
                    this.value = '';
                } else if (e.key === 'Backspace' && !this.value && inlineRuleKeywords.length > 0) {
                    removeInlineKeyword(inlineRuleKeywords.length - 1);
                }
            });
            
            keywordInput.addEventListener('input', debounce(previewInlineRule, 300));
        }
        
        // Don't pre-fill keywords - let user choose
        inlineRuleKeywords = [];
        renderInlineKeywords();
    }
    
    function showCategoryAutocomplete(container, search, onSelect, fieldType = 'category', showAll = false) {
        // Get the right set of options based on field type
        let allOptions;
        if (fieldType === 'necessity') {
            allOptions = [...knownNecessities];
        } else if (fieldType === 'recurrence') {
            allOptions = [...knownRecurrences];
        } else {
            allOptions = Array.from(knownCategories).sort();
        }
        
        let matches;
        const searchTerm = search.trim().toLowerCase();
        
        if (showAll || !searchTerm) {
            // Show all options (limited to 10)
            matches = allOptions.slice(0, 10);
        } else {
            // Filter by search term
            matches = allOptions
                .filter(opt => opt.toLowerCase().includes(searchTerm))
                .slice(0, 8);
        }
        
        if (matches.length === 0) {
            container.classList.remove('show');
            return;
        }
        
        container.innerHTML = matches.map(opt => {
            if (searchTerm && opt.toLowerCase().includes(searchTerm)) {
                const idx = opt.toLowerCase().indexOf(searchTerm);
                const before = opt.substring(0, idx);
                const match = opt.substring(idx, idx + searchTerm.length);
                const after = opt.substring(idx + searchTerm.length);
                return `<div class="autocomplete-item" data-value="${escapeHtml(opt)}">
                    ${escapeHtml(before)}<span class="match">${escapeHtml(match)}</span>${escapeHtml(after)}
                </div>`;
            } else {
                return `<div class="autocomplete-item" data-value="${escapeHtml(opt)}">${escapeHtml(opt)}</div>`;
            }
        }).join('');
        
        container.classList.add('show');
        
        // Click handler
        container.querySelectorAll('.autocomplete-item').forEach(item => {
            item.addEventListener('click', function() {
                onSelect(this.dataset.value);
            });
        });
    }
    
    function addInlineKeyword(keyword) {
        if (!inlineRuleKeywords.map(k => k.toLowerCase()).includes(keyword.toLowerCase())) {
            inlineRuleKeywords.push(keyword);
            renderInlineKeywords();
            previewInlineRule();
        }
    }
    
    function removeInlineKeyword(index) {
        inlineRuleKeywords.splice(index, 1);
        renderInlineKeywords();
        previewInlineRule();
    }
    
    function renderInlineKeywords() {
        const wrapper = document.getElementById('inlineKeywordsWrapper');
        if (!wrapper) return;
        const input = document.getElementById('inlineKeywordInput');
        
        // Remove existing tags
        wrapper.querySelectorAll('.inline-keyword-tag, .inline-and-connector').forEach(el => el.remove());
        
        // Add keyword tags before input
        inlineRuleKeywords.forEach((kw, i) => {
            if (i > 0) {
                const connector = document.createElement('span');
                connector.className = 'inline-and-connector';
                connector.textContent = 'AND';
                wrapper.insertBefore(connector, input);
            }
            
            const tag = document.createElement('span');
            tag.className = 'inline-keyword-tag';
            tag.innerHTML = `${escapeHtml(kw)}<span class="remove" onclick="removeInlineKeyword(${i})">×</span>`;
            wrapper.insertBefore(tag, input);
        });
    }
    
    async function previewInlineRule() {
        const previewDiv = document.getElementById('inlinePreview');
        const placeholder = previewDiv?.querySelector('.inline-preview-placeholder');
        const contentDiv = previewDiv?.querySelector('.inline-preview-content');
        
        if (!previewDiv) return;
        
        if (inlineRuleKeywords.length === 0) {
            // Show placeholder, hide content
            if (placeholder) placeholder.style.display = 'block';
            if (contentDiv) contentDiv.style.display = 'none';
            return;
        }
        
        try {
            const response = await fetch('/api/category-rules/preview', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ keywords: inlineRuleKeywords })
            });
            const data = await response.json();
            
            // Hide placeholder, show content
            if (placeholder) placeholder.style.display = 'none';
            if (contentDiv) contentDiv.style.display = 'block';
            
            document.getElementById('inlinePreviewCount').textContent = data.matching_count;
            
            // Show matching transactions
            const matchesDiv = document.getElementById('inlinePreviewMatches');
            if (matchesDiv && data.matches && data.matches.length > 0) {
                matchesDiv.innerHTML = data.matches.map(m => 
                    `<div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.15rem; padding: 0.2rem 0; border-bottom: 1px solid var(--border-color);">
                        <span style="color: var(--text-primary);">${escapeHtml(m.description.substring(0, 50))}${m.description.length > 50 ? '...' : ''}</span>
                        <span style="font-size: 0.58rem; margin-left: 0.25rem;">$${Math.abs(m.amount || 0).toFixed(2)}</span>
                    </div>`
                ).join('');
            } else if (matchesDiv) {
                matchesDiv.innerHTML = '<div style="font-size: 0.62rem; color: var(--text-secondary); font-style: italic;">No matching transactions found</div>';
            }
        } catch (error) {
            console.error('Preview error:', error);
        }
    }
    
    async function saveInlineRule() {
        const categoryInput = document.getElementById('inlineRuleCategory');
        const necessitySelect = document.getElementById('inlineRuleNecessity');
        const recurrenceSelect = document.getElementById('inlineRuleRecurrence');
        
        const category = categoryInput ? categoryInput.value.trim() : '';
        const necessity = necessitySelect ? necessitySelect.value : '';
        const recurrence = recurrenceSelect ? recurrenceSelect.value : '';
        
        // Build tags object with only non-empty values
        const tags = {};
        if (category) tags.category = category;
        if (necessity) tags.necessity = necessity;
        if (recurrence) tags.recurrence = recurrence;
        
        if (Object.keys(tags).length === 0) {
            alert('Please set at least one tag (Category, Necessity, or Recurrence).');
            return;
        }
        
        if (inlineRuleKeywords.length === 0) {
            alert('Please add at least one keyword');
            return;
        }
        
        try {
            const response = await fetch('/api/category-rules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ tags, keywords: inlineRuleKeywords })
            });
            
            const data = await response.json();
            
            if (data.success) {
                closeCategoryDropdown();
                await loadCategoryRules();
                await loadAllTransactions();
                
                // Preserve the current timeframe filter after reloading transactions
                syncTransactionsToTimeframe();
                
                // Mark as unsynced since transactions were updated
                if (data.transactions_updated > 0 && typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                if (data.transactions_updated > 0) {
                    alert(`Rule created! ${data.transactions_updated} transaction(s) updated.`);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Save error:', error);
            alert('Error saving rule');
        }
    }
    
    async function saveInlineFieldRule(fieldType) {
        let value = '';
        
        if (fieldType === 'necessity') {
            const select = document.getElementById('inlineRuleNecessity');
            value = select ? select.value : '';
        } else if (fieldType === 'recurrence') {
            const select = document.getElementById('inlineRuleRecurrence');
            value = select ? select.value : '';
        }
        
        if (!value) {
            alert('Please select a value for the rule');
            return;
        }
        
        if (inlineRuleKeywords.length === 0) {
            alert('Please add at least one keyword');
            return;
        }
        
        try {
            const response = await fetch('/api/category-rules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    category: value, 
                    keywords: inlineRuleKeywords, 
                    field: fieldType 
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                closeCategoryDropdown();
                await loadCategoryRules();
                await loadAllTransactions();
                
                // Preserve the current timeframe filter after reloading transactions
                syncTransactionsToTimeframe();
                
                // Mark as unsynced since transactions were updated
                if (data.transactions_updated > 0 && typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                if (data.transactions_updated > 0) {
                    alert(`Rule created! ${data.transactions_updated} transaction(s) updated with ${fieldType}="${value}".`);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Save error:', error);
            alert('Error saving rule');
        }
    }
    
    function closeCategoryDropdown() {
        if (activeDropdown) {
            activeDropdown.remove();
            activeDropdown = null;
            activeDropdownData = null;
            activeTagType = null;
            inlineRuleKeywords = [];
        }
        document.removeEventListener('click', closeCategoryDropdownOutside);
    }
    
    function closeCategoryDropdownOutside(e) {
        if (activeDropdown && !activeDropdown.contains(e.target) && 
            !e.target.classList.contains('transaction-category') &&
            !e.target.classList.contains('mini-badge')) {
            closeCategoryDropdown();
        }
    }
    
    async function updateTransactionField(description, date, field, value) {
        try {
            const response = await fetch('/api/transactions/update-field', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ description, date, field, value })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update local data
                const tx = allTransactions.find(t => 
                    t.description === description && t.transaction_date === date
                );
                if (tx) {
                    // Update all fields that were changed (e.g., setting category to Income clears necessity)
                    if (data.updated_fields) {
                        for (const [f, v] of Object.entries(data.updated_fields)) {
                            tx[f] = v;
                        }
                    } else {
                        tx[field] = value;
                    }
                }
                
                // Mark as unsynced
                if (typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                // Re-render
                closeCategoryDropdown();
                renderTransactions(displayedTransactions || allTransactions);
            }
        } catch (error) {
            console.error('Error updating field:', error);
        }
    }
    
    async function saveTransactionCategory(description, date, newCategory) {
        if (!newCategory) {
            closeCategoryDropdown();
            return;
        }
        
        try {
            const response = await fetch('/api/transactions/update-category', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ description, date, category: newCategory })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update local data
                const tx = allTransactions.find(t => 
                    t.description === description && t.transaction_date === date
                );
                if (tx) {
                    tx.category = newCategory;
                }
                
                // Mark as unsynced
                if (typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                // Re-render
                closeCategoryDropdown();
                renderTransactions(allTransactions);
                knownCategories.add(newCategory);
            }
        } catch (error) {
            console.error('Error updating category:', error);
        }
    }
    
    function debounce(func, wait) {
        let timeout;
        return function(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }
    
    // =========================================================================
    // SWEEP RULES MANAGEMENT (Exclusion Rules)
    // =========================================================================
    
    let sweepRules = [];
    let newSweepKeywords = [];
    let selectedSweepRules = new Set();
    
    // Load sweep rules on page load
    document.addEventListener('DOMContentLoaded', function() {
        loadSweepRules();
        setupSweepKeywordInput();
    });
    
    function toggleSweepPanel() {
        closeCategoryDropdown();
        document.getElementById('sweepPanel').classList.toggle('open');
        document.getElementById('panelOverlay').classList.toggle('show');
    }
    
    function closeSweepPanel() {
        document.getElementById('sweepPanel').classList.remove('open');
        document.getElementById('panelOverlay').classList.remove('show');
    }
    
    function closeAllPanels() {
        closeRulesPanel();
        closeSweepPanel();
    }
    
    async function loadSweepRules() {
        try {
            const response = await fetch('/api/sweep-rules');
            const data = await response.json();
            sweepRules = data.rules || [];
            renderSweepRulesList();
        } catch (error) {
            console.error('Error loading sweep rules:', error);
        }
    }
    
    async function runAllSweepRules() {
        if (sweepRules.length === 0) {
            alert('No sweep rules to apply.');
            return;
        }
        
        const btn = document.querySelector('.btn-run-all.sweep');
        const originalText = btn.innerHTML;
        btn.disabled = true;
        btn.innerHTML = '⏳ Running...';
        
        try {
            const response = await fetch('/api/sweep-rules/apply-all', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
            });
            
            const data = await response.json();
            
            if (data.success) {
                await loadAllTransactions();
                syncTransactionsToTimeframe();
                if (typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                alert(`Applied all sweep rules! ${data.swept_count || 0} transaction(s) swept.`);
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            alert('Error: ' + error.message);
        } finally {
            btn.disabled = false;
            btn.innerHTML = originalText;
        }
    }
    
    function renderSweepRulesList() {
        const container = document.getElementById('sweepRulesList');
        
        if (sweepRules.length === 0) {
            container.innerHTML = `
                <div style="color: var(--text-secondary); font-size: 0.75rem; text-align: center; padding: 1rem;">
                    No sweep rules yet. Create one above!
                </div>
            `;
            updateSweepJoinBar();
            return;
        }
        
        container.innerHTML = sweepRules.map(rule => {
            const isJoined = rule.keywords.length === 1 && rule.keywords[0].includes('|OR|');
            let keywordsHtml;
            
            if (isJoined) {
                const keywordSets = rule.keywords[0].split('|OR|');
                keywordsHtml = keywordSets.map((set, setIndex) => {
                    const keywords = set.split(',').map(k => k.trim()).filter(k => k);
                    const kwHtml = keywords.map((kw, i) => `${i > 0 ? '<span class="and-connector">AND</span>' : ''}<span class="sweep-keyword">${escapeHtml(kw)}</span>`).join('');
                    return `${setIndex > 0 ? '<span class="or-connector">OR</span>' : ''}(${kwHtml})`;
                }).join(' ');
            } else {
                keywordsHtml = rule.keywords.map((kw, i) => `${i > 0 ? '<span class="and-connector">AND</span>' : ''}<span class="sweep-keyword">${escapeHtml(kw)}</span>`).join('');
            }
            
            return `
                <div class="sweep-item ${rule.enabled ? '' : 'disabled'} ${selectedSweepRules.has(rule.id) ? 'selected' : ''}">
                    <div class="sweep-item-header">
                        <label class="rule-select">
                            <input type="checkbox" ${selectedSweepRules.has(rule.id) ? 'checked' : ''} onchange="toggleSweepRuleSelection('${rule.id}')">
                        </label>
                        <span class="sweep-keyword-display">${rule.title ? escapeHtml(rule.title) : 'Sweep Rule'}${isJoined ? ' <span class="joined-badge">JOINED</span>' : ''}</span>
                        <div class="sweep-actions">
                            <button class="btn-toggle-sweep" onclick="toggleSweepRule('${rule.id}')" title="${rule.enabled ? 'Disable' : 'Enable'}">
                                ${rule.enabled ? '✓' : '○'}
                            </button>
                            <button class="btn-delete-sweep" onclick="deleteSweepRule('${rule.id}')" title="Delete">✕</button>
                        </div>
                    </div>
                    <div class="sweep-keywords">${keywordsHtml}</div>
                    ${rule.swept_count ? `<div class="sweep-stats">Swept ${rule.swept_count} transaction(s)</div>` : ''}
                </div>
            `;
        }).join('');
        
        updateSweepJoinBar();
    }
    
    function toggleSweepRuleSelection(ruleId) {
        if (selectedSweepRules.has(ruleId)) {
            selectedSweepRules.delete(ruleId);
        } else {
            selectedSweepRules.add(ruleId);
        }
        renderSweepRulesList();
    }
    
    function clearSweepSelection() {
        selectedSweepRules.clear();
        renderSweepRulesList();
    }
    
    function updateSweepJoinBar() {
        const bar = document.getElementById('joinSweepBar');
        if (!bar) return;
        const count = selectedSweepRules.size;
        bar.style.display = count > 0 ? 'flex' : 'none';
        document.getElementById('selectedSweepCount').textContent = count;
    }
    
    async function joinSelectedSweepRules() {
        if (selectedSweepRules.size < 2) {
            alert('Please select at least 2 rules to join.');
            return;
        }
        
        const title = prompt('Enter a title for the joined rule (optional):');
        
        try {
            const response = await fetch('/api/sweep-rules/join', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    rule_ids: Array.from(selectedSweepRules),
                    title: title || ''
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                selectedSweepRules.clear();
                await loadSweepRules();
                alert(`Joined ${data.joined_count} rules!`);
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            alert('Error: ' + error.message);
        }
    }
    
    function setupSweepKeywordInput() {
        const input = document.getElementById('sweepKeywordInput');
        if (!input) return;
        
        const wrapper = document.getElementById('sweepKeywordsWrapper');
        
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && this.value.trim()) {
                e.preventDefault();
                addSweepKeyword(this.value.trim());
                this.value = '';
            } else if (e.key === 'Backspace' && !this.value && newSweepKeywords.length > 0) {
                removeSweepKeyword(newSweepKeywords.length - 1);
            }
        });
        
        input.addEventListener('input', debounce(previewSweepRule, 500));
    }
    
    function addSweepKeyword(keyword) {
        if (!newSweepKeywords.includes(keyword.toLowerCase())) {
            newSweepKeywords.push(keyword);
            renderSweepKeywords();
            previewSweepRule();
        }
    }
    
    function removeSweepKeyword(index) {
        newSweepKeywords.splice(index, 1);
        renderSweepKeywords();
        previewSweepRule();
    }
    
    function renderSweepKeywords() {
        const wrapper = document.getElementById('sweepKeywordsWrapper');
        const input = document.getElementById('sweepKeywordInput');
        
        // Remove existing tags
        wrapper.querySelectorAll('.keyword-tag, .and-connector').forEach(el => el.remove());
        
        // Add tags before input
        newSweepKeywords.forEach((kw, i) => {
            if (i > 0) {
                const connector = document.createElement('span');
                connector.className = 'and-connector';
                connector.textContent = 'AND';
                wrapper.insertBefore(connector, input);
            }
            
            const tag = document.createElement('span');
            tag.className = 'keyword-tag';
            tag.innerHTML = `${escapeHtml(kw)} <span class="remove-keyword" onclick="removeSweepKeyword(${i})">×</span>`;
            wrapper.insertBefore(tag, input);
        });
    }
    
    async function previewSweepRule() {
        const previewSection = document.getElementById('sweepPreviewSection');
        
        if (newSweepKeywords.length === 0) {
            previewSection.style.display = 'none';
            return;
        }
        
        try {
            const response = await fetch('/api/sweep-rules/preview', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ keywords: newSweepKeywords })
            });
            
            const data = await response.json();
            
            previewSection.style.display = 'block';
            document.getElementById('sweepPreviewCount').textContent = data.match_count || 0;
            
            const matchesDiv = document.getElementById('sweepPreviewMatches');
            if (data.sample_matches && data.sample_matches.length > 0) {
                // Show ALL matching transactions, not just a few
                matchesDiv.innerHTML = data.sample_matches.map(m => 
                    `<div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 0.15rem;">• ${escapeHtml(m)}</div>`
                ).join('');
            } else {
                matchesDiv.innerHTML = '';
            }
        } catch (error) {
            console.error('Preview error:', error);
        }
    }
    
    function resetSweepForm() {
        document.getElementById('sweepRuleTitle').value = '';
        document.getElementById('sweepKeywordInput').value = '';
        newSweepKeywords = [];
        renderSweepKeywords();
        document.getElementById('sweepPreviewSection').style.display = 'none';
    }
    
    async function saveSweepRule() {
        const title = document.getElementById('sweepRuleTitle').value.trim();
        
        if (!title) {
            alert('Please enter a title for this sweep rule.');
            return;
        }
        
        if (newSweepKeywords.length === 0) {
            alert('Please add at least one keyword.');
            return;
        }
        
        try {
            const response = await fetch('/api/sweep-rules', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    title: title,
                    keywords: newSweepKeywords
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                resetSweepForm();
                await loadSweepRules();
                await loadAllTransactions(); // Refresh transactions list
                
                // Preserve the current timeframe filter after reloading transactions
                syncTransactionsToTimeframe();
                
                // Mark as unsynced since transactions were removed
                if (typeof markAsUnsynced === 'function') {
                    markAsUnsynced();
                }
                
                if (data.swept_count > 0) {
                    alert(`Swept ${data.swept_count} transaction(s)!`);
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Error saving sweep rule:', error);
            alert('Error saving sweep rule. Please try again.');
        }
    }
    
    async function deleteSweepRule(ruleId) {
        if (!confirm('Delete this sweep rule? Previously swept transactions will NOT be restored.')) return;
        
        try {
            const response = await fetch(`/api/sweep-rules/${ruleId}`, {
                method: 'DELETE'
            });
            
            const data = await response.json();
            
            if (data.success) {
                await loadSweepRules();
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            console.error('Delete error:', error);
        }
    }
    
    async function toggleSweepRule(ruleId) {
        const rule = sweepRules.find(r => r.id === ruleId);
        if (!rule) return;
        
        try {
            const response = await fetch(`/api/sweep-rules/${ruleId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ enabled: !rule.enabled })
            });
            
            if (response.ok) {
                await loadSweepRules();
            }
        } catch (error) {
            console.error('Toggle error:', error);
        }
    }
</script>
{% endblock %}
